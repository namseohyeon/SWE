# 10. 테스트

포인트1. 테스트 작업의 원리와 목표는 무엇인가? 

포인트2. 테스트 단계와 종류에는 어떤 것이 있는가? 

포인트3. 블랙박스 테스트와 화이트박스 테스트 기법은 어떻게 하는 것인가? 

포인트4. 상태 기반 테스트 기법은 무엇인가?   

포인트5. 통합, 시스템, 인수 테스트를 하는 방법은 무엇인가? 

소프트웨어 개발은 오류가 발생하기 쉬운 활동
> 결합을 낮추기 위해 방지, 식별 후 제거

테스트 - 시험할 소프트웨어에 테스트 케이스를 줘 실행시킨 후 실핼시킨 후 시스템 동작이 예상한대로 실행되는지 확인

검증과 확인
- 검증 : 제품을 올바르게 구축하고 있는가?(비기능 요구사항을 얼마나 잘 준수하는가?)
- 확인 : 올바른 제품을 만들고 있는가? (제품이 사용자의 기대에 얼마나 잘 충족하는가?)
![image](https://user-images.githubusercontent.com/64974683/206349932-d629c26b-25e6-45d4-b737-7186692ca289.png)

## 10-1 테스트 기초

### 10-1-1 버그, 오류, 결합, 고장
- 버그: 문제, 결합 또는 난이도를 나타내는 일반적으로 사용
- 오류: 개발자가 잘못하여 설계나 코딩에 실수 한 것
- 결합: 코드 또는 문서에 오류가 있는 경우 발생하는 것, 시스템이 고장을 일으키게 하는 오류의 결과
- 고장: 시스템이 우너하는 작업을 수행할 수 없는 상황(시스템 결함이 있으면 고장 발생)
> 오류 > 결합 > 고장

### 10-1-2 테스트 원리
1. 테스트는 오류를 발견하려고 시스템 실행
  - 테스트의 잘못된 관점(테스트는 프로그램이 작동한다는 것을 보여주려는 것)
  - 오류 발견하려는 테스트는 어렵고, 복잡하지만 더 성공적인 테스트
2. 완벽한 테스트는 불가능
  - 프로그램 테스트는 증명과 다르다(테스트에 문제가 없다고 해서 오류가 없는 것은 x)
  - 완벽하게 테스트하기 위한 테스트 케이스 작성은 이론적으로만 가능(시간, 비용문제)
  - 따라서 효율적인 테스트 케이스의 부분집합을 테스트해야함
3. 테스트는 창조적인 일이며 힘든 일
  - 테스트와 유지보수는 창의력 요구 + 전문가에게는 흥미의 대상
  - 효율적 테스트 > 프로그램이 무엇을 하는지에 대한 이해, 테스트 기법 숙지, 효율적인 적용기술 필요
4. 테스트는 오류의 유입을 방지할 수 있음
  - 오류나 문제의 존재를 빠르게 알 수록 수정 비용이 적어짐
  - 요구분석, 설계 단계(초기 단계)에 오류가 유입되는 것을 적극적으로 막아야함
5. 테스트는 구현과 관계없는 독립된 팀에 의해 수행되어야함
  - 테스트는 객관적인 입장으로 진행되어야 효과적인 테스트가 가능

### 10-1-3 테스트 작업 과정
1. 테스트에 의하여 무엇을 점검할 것인지 정함
  - 테스트 설계전 테스트 목표 정하기
2. 테스트 방법을 결정
  - 어떻게 테스트 할지 결정
3. 테스트 케이스 개발 
  - 테스트 케이스 - 테스트 자료, 실행될 조건
4. 테스트의 예상되는 올바른 결과 작성
  - 올바른 결과를 미리 구체적으로 예상, 작성하여 테스트 케이스 실행의 통과, 실패에 대한 기준으로 삼음 
5. 테스트 케이스로 실행
  - 테스트 하니스: 시스템의 일부기능만 시험하기 위해 소프트웨어에 변경을 가하는 경우
  - 테스트 하니스는 완전히 테스트가 띁나면 제거
![image](https://user-images.githubusercontent.com/64974683/206352592-6d55984f-4780-4688-afa2-2e5533739670.png)

테스트 단계(테스트는 여러 단계로 나눠 진행)
- 단위 테스트
  - 각 모듈 시험
  - 모듈 구현한 프로그래머가 실시
  - 목적 : 모듈은 정확하게 구현? 예정한 기능을 제대로 발휘하는가?
- 통합 테스트
  - 전체 시스템이 이루는 모듈 모아 통합적으로 시험
  - 목적 - 시스템이 요구하는 기능 제대로 수행? 모듈 사이 인터페이스 시험
- 시스템 테스트
  - 완전된 제품에 대한 시험
  - 목적: 시스템이 사용될 준비가 다 되었음을 드러내는 것
- 인수 테스트
  - 사용될 환경에서 설치하여 사용자가 직접 사용하여 시험
  - 시스템의 문자도 점검
- 리그레션 테스트
  - 시스템 설치 후 유지보수 단계에 이루어진 테스트
  - 수정이 이뤄진 부분, 그에 의한 영향을 시험
  ![image](https://user-images.githubusercontent.com/64974683/206353108-14fc90bd-d2c2-4921-981a-472112bca3b6.png)

### 10-1-4 테스트 케이스
- 결함을 검사할 수 있는 입력이 있어야 테스트를 위해 실행할 수 있음
- 시험조건, 테스트 데이터, 예상 결과를 포함시켜야함
- 테스트 방법이 제안하는 조건을 만족하는 테스트 케이스를 신중히 선택

## 10-2 블랙박스 테스트
내부경로(내부 코드 구조, 구현 세부사항)에 대한 지식을 보지 않고, 테스트 대상의 기능이나 성능 테스트
> 전적으로 소프트웨어 요구 사항 및 사양을 기반
> 입력/출력에 중점
![image](https://user-images.githubusercontent.com/64974683/206361223-1b8df4b0-7a8e-4482-bc80-062e31954ae3.png)

- 장점
  - 테스트하기 위한 기술적 배경이 필요아지 않다 - 사용자의 입장에서 테스트
  - 코디잉 완료되어야 테스트 시작 가능 - 테스터와 개발자가 서로 방해하지 않고, 독립적인 작업 가능
  - 크고 복잡한 응용 프로그램에 더욱 효과적
  - 테스트 초기 단계에서 결함, 불일치 식별 가능
 - 단점
  - 기술적 또는 프로그래밍 지식이 없으면 테스트할 시나리오의 가능한 조건을 무시할 가능성 있음
  - 규정된 시간에 가능한 적은 입력을 테스하고, 가능한 모든 입력과 출력 테스트를 건너뛸 수 있음
  - 크고 복잡한 테스트 대상은 완전한 테스트 범위 불가능

### 10-2-1 동등 분할 기법
동등 클래스 - 시스템의 동작이 같을 것으로 예상되는 입력들로 구성
> 동작이 다를 것으로 예상 되면  다른동등 클래스와 분리되어야함

동등 클래스에서 테스트 케이스를 선택할 때는 정상적인 입력만 생각하는 것이 아닌 비정상적인 입력도 고려해야함

### 10-2-2 경계값 분석
경계값 분석에서 유효한 입력과 유효하지 않은 입력을 모두 테스트하여 문제를 확인하는 방법
> 경계 - 시스템의 동작이 변경되는 한계 근처의 값
> 동치 클래스의 결계에 있는 값을 테스트 입력으로 선택
![image](https://user-images.githubusercontent.com/64974683/206363301-fbe77e63-8c8d-469f-94d1-4c3410cee947.png)

테스트 케이스에 여러 경곗값의 조합을 선택하는 방법
- 하나의 변수에 대하여 여러 경곗값들을 선택하면서 다른 변수는 정상적인 값으로 고정
- 모든 변수에 대하여 범위안의 정상적인 값을 가진 테스트 케이스를 추가

동등 분할, 경곗삾 분석의 단점
- 입력 조건이나 클래스의 조합을 고려하지 않음
- 모든 조합을 대상으로 테스트 > 너무 많은 테스트 케이스 필요

### 10-2-3 원인 결과 그래프
- 입력 조건의 조합을 체계적으로 선택하여 너무 많게 되지 않게 하는 기법
- 테스트하려는 시스템의 원인과 결과 파악
- 원인 : 구별되는 입력 조건
- 결과ㅣ 기호(and,or,not로 표시)
- 장점:
-   좋은 케이스르를 만들어 줌
-   시스템의 기능을 이해하는데 도움 > 서로 다른 원인과 결과를 잘 구별할 수 있기 때문

결정 테이블
  - 원인 결과 그래프로부터 테스트 케이스를 만들때 사용
  - 결과 하나를 참으로 정하고 조건을 가능하게 만드는 원인을 찾음
  - 원인들의 조건이 테스트 케이스를 구성
  - 1:참, 0:거짓, x:참, 거짓 관계 없음

## 10-3 화이트박스 테스트
프로그램이 수행하는 기능에 초점을 맞춰 테스트하는 방법
- 화이트박스 테스트의 단계
  1. 원시코드를 통해 애플리케이션의 구조 이해 - 논리 흐름도 이용
  2. 검증 기준을 정함
  3. 각 경로를 구동시키는 테스트 데이터를 준비, 결과 비교

### 10-3-1 논리 흐름의 표현
- 논리 흐름도
  - 모듈 내의 제어 흐름을 간선으로 표현
  - 모듈 내의 세그먼트가 그래프 정점으로 표현됨
  - 세그먼트와 선택구조 사이의 제어흐름은 간선으로 표시됨
  - 논리 흐름에 관계되지 않은 사항은 생략하여 나타냄

### 10-3-2 검증기준
- 테스트 실행이 프로그램의 어떤 기준을 커버하는지 결정하는 것
- 문장 커버리지
  - 코드의 각 라인이 적어도 한번 이상 실행되는지 검증하는 방법
- 분기 커버리지
  - 코드에서 각 분기가 한번 이상 실행되는지 확인하는 방법
- 경로 커버리지 
  - 경로 커버리지는 프로그램의 모든 실핼 경로를 테스트하는 기준
  - 모든 경로를 체크하기에는 분기 커버리지보다 강력
  - 경로가 복잡한 프로그램을 테스트하는데 유용
- 루프 테스트
  - 4가지 반복 구조
    1. 단순 반복문 테스트 : 경계값 분석에서 사용했던 방법 적용
      - 5가지 케이스로 나누어 테스트
        1. 반복구조를 들어가지 않고 생략
        2. 반복 구조 안에서 한번 반복
        3. 범위 내의 임의 반복
        4. 반복 최대 횟수 -1만큼 반복
        5. 반복 최대 횟수 만큼 반복
       ![image](https://user-images.githubusercontent.com/64974683/206367655-7afa3fad-3ee5-44e2-a4af-67febf40155c.png)

    2. 중첩된 반복문 테스트
      - 가장 내부에 있는 반복 구조부터 하나씩 단순 반복문 테스트 진행
      - 테스트가 진행중이지 않은 반복문 중, 내부에 있는 반복문은 최소횟수, 회부에 있는 반복문은 임의 횟수 반복
    ![image](https://user-images.githubusercontent.com/64974683/206367781-0fa50074-682d-4e47-b695-71fcb87cab04.png)

    3. 연속된 반복
      - 반복구조가 서로 독립적 > 단순 반복 구조와 같은 방법으로 테스트
      - 직/간접적으로 의존 관계가 존재 > 중첩된 반복 구조와 같은 방법으로 테스트
    ![image](https://user-images.githubusercontent.com/64974683/206367941-d9df8299-323d-4489-a99c-21832aea9ae9.png)

## 10-4 상태기반 테스트
- 시스템의 동작은 시스템의 상태에 의해 좌우
- 상태와 트랜지션에 집중 > 간단한 경우가 많은 테스트 케이스가 나오며, 상태가 늘어나면 급격히 증가
- 입력 도메인만 보고 설계하면 시스템의 상태를 고려하지 않아 테스트 시나리오가 간과되기 쉬움

상태모델은 네가지 요소로 구성
- 상태: 시스템의 과거 입력에 대한 영향을 표시
- 트랜지션: 이벤트에 대한 반응, 시스템이 하나의 상태에서 다른 상태로 어떨게 변해가는지
- 이벤트 : 시스템에 대한 입력
- 액션: 이벤트에 대한 출력

상태모델의 테스트 케이스
- 세가지의 검증 기준
  - 모든 트랜지션 : 테스트 케아스 집합이 상태 그래프의 모든 트랜지션을 점검
  - 모든 트랜지션 쌍 
    - 테스트 케이스 집합이 모든 이웃 트랜지션의 쌍을 점검
    - 이웃 트랜지션 : 어떤 상태에 들어오는 유입 트랜지션, 방출 트랜지션의 쌍
    - 유입/방출 트랜지션의 모든 조헙 검사 > 첫번째 기준보다 강함
   - 트랜지션 트리
    - 테스트 케이스의 집합이 모든 단순 경로를 만족시키는 기준
    - 단순 경로 : 시작 상태에서 출발하여 그래프에 있는 다은 상태로 중복되지 않고, 방문될 수 있는 경로

## 10-5 통합테스트 
- 시스템을 구성하는 모듈들의 인터페이스 결합율 테스트
- 단위 모듈을 개발한 후 이들 사이에 인터페이스가 잘되는지 테스트하려는 목적을 가짐
- 시스템을 구성하는 여러 모듈들을 어떤 순서로 결합/ 테스트 할 것 이냐에 따라 아래처럼 분류

### 10-5-1 빅뱅 통합
한번에 모든 모듈을 모아 통합하는 방법
- 개발하는 모듈에 대하여 일정한 마감일을 정하고, 완성된 모듈을 모아 통합
- 장점:
  - 일정 관리 편함
  - 통합을 위한 스텁 구성할 필요x
- 단점:
  - 모든 구성요소를 동시에 통합하기 떄문에 중대한 오류가 발생한 가능성이 높음
  - 버그가 발견되면 근본 원인을 찾기 위해 모든 모듈을 분리하기 어려움(모든 모듈이 한번에 테스트 되기 때문)
  - 프로덕션 환경에서 치명적인 버그 발생 가능성 높다
  - 일정 계획에 융통성 없음

### 10-5-2 하향식 통합(top-down)
시스템 구조도의 위층에 있는 모듈부터 아래층의 모듈로 내려오면서 통합
![image](https://user-images.githubusercontent.com/64974683/206369530-d4658de5-e221-49df-a57d-03cc193f59a1.png)
- 최상위 증의 모듈에 대한 드라이버와 스텁을 작성한 후, 통과되묜 스텁을 대상 모듈로 교체
- 테스트 대상 모듈이 호출하는 모듈은 스텁을 작성하여 통합 테스트를 진행
- 장점
  - 점층적인 통합 형태 > 라드웨어 사용이 분산, 오류의 원인 찾기 쉬움
  - 상위층의 모듈을 먼저 시험 > 시스템의 계층구조와 상위층의 중요한 인터페이스를 조기 시험 가능
  - 스텁의 사용으로 시스템의 모습을 사용에게 일찍 보여줄 수 있음
- 단점
  - 입/출력을 수행하는 모듈이 대부분 최하위에 존재 > 테스트에 어려움
  - 마지막 통합 > 상위층에서 테스트 케이스 사용 어려움
  - 중요한 기능을 하는 최하위층 모듈을 충분한 시험할 수 없음

### 10-5-3 상향식 통합(bottom-up)
최하위 모듈을 먼저 통합하여 시험하는 방법
- 다음에 위층의 모듈이 추가되어 서브시스템을 이룸 > 서브 시스템을 계속 크게 만들어 나감
- 스텁이 필요없고, 드라이버 필요
![image](https://user-images.githubusercontent.com/64974683/206370108-fa8c8ac4-bff9-4839-8ca9-2a3f0280e07d.png)

최하위층을 구동하는 드라이버를 준비하여 통합한 후, 통과되면 드라이버 대신 개발된 모듈로 대체, 드라이버로 통합시켜 나감 > 메인 모듈이 통합될 때까지 반복

- 장점
  - 점층적으로 통합 > 오류 발견 쉽고, 하드웨어 사용 분산
  - 하위층의 모듈을 상위층의 모듈보다 더 많아 테스트 > 하위층에 중요한 기능의 모듈이 많은 경우 적합
- 단점
  - 테스트 초기에 시스템의 뼈대가 갖추어지지 않음
  - 시스템의 모든 계층과 상위층의 중요한 인터페이스 등을 마지막 가서 확인 가능
  - 상위층에 있는 시스템의 골격이 상대적으로 적게 반복 - 테스트 기회 충분x

### 10-5-4 연쇄식 통합
특정 기능을 수행하는 모듈의 최소 단위(thread)로부터 시작
> 기본 기능을 수행하는 모듈로부터 통합테스트 해나가는 방법
=> 상대적으로 중요한 모듈부터 개발

장점
- 통합 초기에 시스템의 골격을 보여주고 사용자의 의견을 빠르게 받을 수o
- 대규모 시스템의 경우 초판은 시스템의 주요 기능만 수행, 추후 부가적인 기능을 첨부
- 시스템이 여러 프로그래머에게 나누어 개발될 수 있고, 각 프로그래머도 시스템의 부분적 개발 진도를 확인 가능

- 단점
스레드의 구성이 복잡해질 수 있음 -> 드라이버와 스텁 작성에서 오류가 발생할 수 있음

### 10-6-1 기능테스트
- 기능적 용구와 시스템의 차이 발견
- 사용자와 관련되어 있으며, 오류를 유발할 가능성이 많은 테스트 선정
- 사용사례 모델을 검토, 오류를 일으킬만한 유스케이스 인스턴스를 찾아냄

### 10-6-2. 성능 테스트
시스템의 여러 측면(시스템의 작업 부하, 처리량, 반응 시간 등)들을 포함하기 위한 목적을 가짐
- 작업 부하 - 시스템이 처리하고 생성하는 작업의 양 측정
- 처리량 - 트랜잭션(상태를 변화시키는 단위)의 수, 시간당 처리하는 메일 수 등을 측정
- 반응 시간 - 시스템 요구를 처리하는 데 걸리는 총 시간 측정
- 효율성 - 주어진 작업 처리를 위한 CPU시간과 메모리 같은 자원의 양의 비율 측정

- 스트레스 테스트
  - 시스템 처리능력의 몇 배의 작업부하를 처리하고 견딜 수 있는지 측정

- 시뮬레이션 기반 성능 테스트
  1. 사용자 모델 구축
  2. 각 트랜잭션 타입에 대한 프로토타입 구축, 트랜잭션 인스턴스를 생성하기 위해 사용
  3. 난수 생성기를 동원하여 사용 프로파일에 비례한 필요한 작업 부하를 생성
 
### 10-6-3. 보안 테스트
- 해커에게 이용될 수 있는 의도하지 않는 기능과 동작 시스템을 찾아내는 것
- 시스템의 보안 약점을 이용할 수 있는 취약점을 찾아내기 위한 목적
- 테스트 케이스 생성 시 화이트박스 테스트 적용 가능
- 무작위로 입력값을 주는 랜덤 테스트도 사용한다
 

### 10-6-4. UI 테스트
인간공학적인 결함을 발견하기 위한 목적을 가짐

- 보고 느끼는 UI에 대한 결함
일관성 없음, 빠짐, 부정확, 복잡, 엉성하게 구성된 윈도우 등이 해당
요구에 적합한지 점검

- 데이터 입/출력 디스플레이에 대한 결함
여러 가지 다른 애플리케이션마다 고유한 입력 데이터 양식과 출력 디스플레이 포맷을 요구할 수 있음
시스템이 정확한 입/출력 데이터, 타입, 포맷을 사용하는지 검사함

- 액터-시스템 사이의 동작 결함
시스템이 상호작용을 설계대로 구현하였는지 검사

- 오류 처리에 대한 결함
오류 미처리, 부정확, 부적절 등을 처리

- 문서와 도움말에 대한 결함
일관성 없음, 빠짐, 불완전, 부정확, 복잡, 엉성하게 작성된 온라인 문서, 도움말 등을 처리
 
### 10-6-5. 인수 테스트
목적
- 시스템을 당장 사용할 수 있도록 모든 준비가 되어 있는지를 보이는 것
- 개발자가 하지 않으며, 개발을 의뢰한 사람 또는 대리인이 진행
- 사용하는 테스트 방법은 사용자가 선택

인수 테스트 방법
1. 시스템 요구 분석서를 기반으로 한 테스트 수행
2. 사용자 환경에서 한다는 점이 차이
3. 실제 사용할 H/W, S/W 기반으로 사용할 사람들이 실제 업무 절차를 따라 수행
4. 새 시스템의 결과, 이전 수작업 시스템의 결과를 비교
5. 성능 시험, 스트레스 시험도 필요함
 

- 알파 테스트
선택된 사용자가 개발환경에서 시험하는 것

- 베타 테스트( = 필드 테스트 )
선택된 사용자에 의하여 외부 환경에서 테스트하는 것
알파 테스트와 병행/대체 가능
