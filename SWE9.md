# 9. 코딩

포인트1. 코딩 작업의 원리와 과정은 무엇인가?

포인트2. 코딩 단계의 과정과 흔히 일어나는 오류는 무엇인가?

포인트3. 코딩 스타일이란 무엇이며 좋은 코드가 되기 위해서 어떤 가이드가 필요한가?

포인트4. 리팩토링이란 무엇이며 코드 스멜, 리팩토링 방법은 무엇인가?

포인트5. 코드 품질을 높이는 방법에는 어떤 것이 있는가?

## 코딩 로드맵
- 실행하는 원시코드가 소프트웨어 품질을 결정하는 핵심
![image](https://user-images.githubusercontent.com/64974683/205557213-1eb7867d-5ddf-424e-9311-5f1b64d3aee2.png)

## 9-1. 코딩 작업
- 코딩을 분리하여 구현할 수 있는 작은 단위를 프로그래밍
- 설계 명세에 나타낸 대로 요구를 만족할 수 있도록 프로그래밍 
- 목표 : 오류가 적은 품질 프로그래밍 작서

### 9-1-1 작업과정
1. 원시코드를 같은 스타일로 만들기 위해 코딩 표준 만듬
2. 아키텍처 설계 결과 프레임 워크 패키지와 응용 패키지를 결정(패키지 내부에 있는 클래스에 대한 요구상항과 상세설계를 반영하여 메서드 코딩)
3. 클래스 구현 끝 > 인스펙션
4. 클래스 단위로 테스트
5. 클래스나 패키지를 릴리스하여 다음 단계인 응용 시스템으로 통합

=> 명명규칙,, 들여쓰기 규칙등 여러사람이 작성하는 코드를 통이하려는 목적으로 만든 가이드 숙지 필요

### 9-1-2 자주 발생 오류
- 메모리 누수: 메모리 free x  > 새로 계속 할당 요구하여 메모리 고갈
- 중복된 프리 선언 : 이미 free로 선언된 자원을 다시 free로 선언할때 오류 생성
- NULL의 사용 : null을 포인트라고 있는 곳의 콘텐츠를 접근 > 오류, 초기화 되지 않는 메모리 접근 오류
- 별칭 남용 : 두개의 변수의 값이 별칭 선언으로 인해 값은 값이 되었을때 문제 발생
- 배열 인덱스 오류 : 베열의 인덱스가 한도를 벗어나면
- 수식 예외 오류
  - 0으로 나눌때
  - 변동 소수점 예외 오류
- 하나 차이에 의한 오류
  - 0으로 시작할 것을 1로 오류
  - 컴파일러나 테스트 도구에 의해서 검출x >사용자의 의도에 맞게 실행되지 않음
  - 사용자 정의 자료형을 다룰 때 오버플로우나 언더 플로우 오류 
- 스트링 처리 오류
  - 스트링 처리 함수(strcpy, sprintf 등)를 사용
  - 매개변수가 NULL일 때
  - 스트링이 NULL로 끝나지 않을 때
  - destination 매개변수의 크기가 충분히 크지 않을 때
  - Overrun 오류가 발생함
- 버퍼 오류
  - 프로그램이 버퍼에 복사하여 입력 받으려 할 때 입력 값을 고의로 아주 크게 주면 스택의 버퍼에 오버플로가 발생함
  - 버퍼 오버플로를 이용하여 리턴 주소를 반환시킴으로써 해커들이 자신의 코드를 실행시킬 수 있음
- 동기화 오류: 공통 자원을 접근하려는 다수의 스레드가 있는 병렬 프로그램에서 흔히 발생
- 동기화 오류 종류
  - 데드락:  다수의 스레드가 서로 자원 점유하고, 릴리스 안한 상태
  - 레이스 컨디션: 두 개의 스레드가 같은 자원을 접근하려 하여 수행 결과가 스레드들의 실행순서에 따라 다르게 되는 경우
  - 모순이 있는 동기화: 공유하는 변수를 접근할때 로킹과 언로킹을 번갈아 하는 상황
  
### 9-2-1 명명 규칙(생략)
### 9-2-2 형식(생략)
### 9-2-3 문장과 수식(생략)
### 9-2-4 오류처리
- 매개변수 오류 > 원하지 않는 매개변수 들어오는 거을 방지
- 입력 오류 > 파라미터의 안전한 디폴트 값을 지정 후, 예외처리 활용(throw)

### 9-2-5 주석
주석을 다는 이유
- 프로그램 작성, 디버깅에 도움을 얻기 위해
- 프로그램을 이해하기 쉽게
- 클래스 불변조건
  - 클래스 속에 대한 의미와 제약의 모음을 주석으로 입력
  - 개별 필드 선언에 대한 주석을 배치되거나 필드 앞에 단일 주석으로 배치
- 메서드 주석
  - 모든 메서드 앞에는 빈줄을 넣고 그 다음에는 메서드가 하는 일을 설명하는 javadoc스펙을 선행조건과 함께 쓰는 것이 좋음
  - java에서는 매개변수 및 메서드 결과 값을 설명하기 위한 규칙이 존재함
  - 메서드 주석을 다는 규칙은 메서드가 무언가를 수행한다는 문장으로 작성하여 관련된 모든 매개 변수를 언급하는 방법
  - 함수에 대한 주석은 일반적으로 반환 대상을 표시하기 위해 작성함
- 클래스 주석
  - public클래스는 별도의 파일에 저장 --> 파일의 시작 부분에 클래스의 용도를 포함하는 주석이 포함되어야 함
  - 저자, 마지막 수정 날짜 등에 관한 정보를 넣는다
- 문장 주석
  - 문장 순서는 논리적 단위로 그룹화 되어야함
  - 문장 주석은 논리 구조 앞에서 의미를 설명하는 주석이 선행되어야 명확성이 향상
  - 문장 주석은 논리단위에 대한 주석

## 9-3 설계에서 코드 생성
객체 지향 패러다임은 분석 > 설계 > 프로그래밍으로의 연결리 자연스러움
IDE도구는 UML다이어그램으로부터 원시코드 골격 자동 생성
IDE도구를 사용하지 않으면 설계보고 직접 코딩 필요

### 9-3-1 연관의 코딩
- 1대1 연관
  - 클래스a와 클래스b사이에 1대1 연관 관계가 있다면 a에서 b의 함수를 호출할 수 있고, a가 b에 대한 참조를 갖도록 구현
  - 반대로 B에서 A의 함수를 호출할 필요가 있다면 B가 A에 대한 참조를 갖도록 구현
 - 1대 n 연관
  - A와 B사이에 1대N의 연관 관계가 있고 클래스 A에서 인스턴스 B의 메서드를 호출할 것이 있다면 클래스 A(Schedule)가 클래스 B(CourseOffering)의 참조를 모음(배열)으로 가지고 있도록 구현
 ![image](https://user-images.githubusercontent.com/64974683/205611887-9c2b908f-18b7-4d39-b8d9-a454f2d30485.png)
- N대 M 연관
  - N대 M의 연관 관계는 중간에 연관 클래스를 도입하여 1대N의 관계로 바꾸어 설계하기도 함
  - N대 M의 연관 관계를 직접 구현하기 위해서는 B객체에 대한 참조 모임을 A가 갖게 하고 A객체에 대한 참조 모임을 B 객체가 갖도록
- 연관을 나타내는 새로운 클래스 도입
  - A와 B 사이의 연관을 AssocAB라는 클래스를 만들어 정의한다고 해 보자, 양쪽 클래스에 상대 인스턴스의 모임을 갖는 참조를 배치

### 9-3-2 시퀀스 다이어그램의 코딩
시퀀스 다이어그램 - 객체의 동작적인 측면을 모델링 한 것 > 오퍼레이션의 종류와 클래스 사이의 관계를 파악하기 위해 각 객체가 주고 받는 메서드를 나타냄
- 시퀀스 다이어그램으로부터 클래스의 메서드를 위한 코드 골격 생성 방법
  - A객체에서 B객체로 나가는 메시지가 표시되어 있다면 그 메시지는 B클래스에 정의되어 있어야 함

## 9-4 리팩토링
이미 존재하는 코드의 디자인을 안전하게 향상  > 단순한 코딩 스타일 개선이 아닌, 좋은 설계가 되도록 개선

### 9-4-1 리팩토링 개념
- 보이는 동작은 변경시키지 않고, 소프트웨어의 많은 것들을 고칠 수 있음
- 리팩토링 목적
  - 소프트웨어의 디자인 개선 - 코드 정돈, 구조가 망가지지 않게 디자인 유지
  - 소프트웨어를 이해하기 쉽게 개선 - 프로그램이 읽기 쉽게 개선
  - 버그를 찾는데 도움
  - 프로그램 빠르게 작성

### 9-4-2 리팩토링 가정
리팩토링 순서
1. 소규모 변경 - 단일 리팩토링
2. 코드 동작 테스트
3. 전체가 잘 작동하면 다음 리팩토링 단계로 전진
4. 작동하지 않으면 문제를 해결하고 리펙토링 한것을 uodo하여 시스템이 작동되도록 유지
=> 리팩토링은 소프트웨어를 쉽게 이해, 적은 비용으로 수정할 수 있도록 겉으로 보이는 동작 변화 없이 내부 구조 변경

### 9-4-3 코드 스멩
- 프로그램에 대한 작업을 어렵게 만드는 것 코드스멜
- 읽기 어려운 프로그램
- 중복된 로직을 가진 프로그램
- 실행중인 코들르 변경해야 하는 특별한 동작을 요구하는 프로그램
- 복잡한 조건문이 포함된 프로그램

코드스멜에 대한 리팩토링 방법
<img width="578" alt="image" src="https://user-images.githubusercontent.com/64974683/205615491-c6350f8c-850f-4e2b-a4b8-5c89a0e9209a.png">
<img width="576" alt="image" src="https://user-images.githubusercontent.com/64974683/205615564-c774c7df-ff72-4cc1-a2bd-1e715463cc3d.png">

9-4-4 리팩토링 사례
- 메서드 추출
  - 재사용 확률이 많은 코드는 메서드로 정의하고 이를 호출
  - 메서드 호출 리펙토링은 코드의 중복을 제거할 수 있는 유용한 방법
- 클래스 추출
  - 클래스 하나당 고유한 책임을 가져야함
- 서브 클래스 추출
  - 클래스 안에서 특정 인스턴스에만 유용한 속성이나, 메서드가 있다면 클래스의 서브 클래스로 만들고, 그런속성이나 메서드로 내려보냄
  - 원래의 클래스는 고유한 추상성 추가 가능
- 메서드 이동
  - 메서드가 정의된 클래스보다 다른 클래스의 기능을 더 많이 사용한다면 다른 메서드로 옮긴다
- 인터페이스 추출
  - 다목적 인터페이스 하나를 만드는 것 보다 다양하게 구현된 특별한 인터페이스가 많아야 한다
- 템플릿 메서드 형성
   - 각 서브 클래스에 있는 두 메서드가 완전히 같지 않지만 비슷한 작업을 한다면 하나로 통일하여 슈퍼 클래스로 올림

## 9-5 코드 품질 개선 기법
 
### 9-5-1 인스펙션
- 프로그램을 수행시켜보는 것 대신 읽어보고 눈으로 확인하는 방법
- 프로그램이 성공적으로 컴파일 되고, 정적 분석 도구에 의하여 검사된 이후 이뤄짐
- 목적
  - 코드에 묻어있는 결합 찾기
  - 결함과 함께 다른 품질 이유등을 검색
  - 인스펙션 단계에서 관심을 가지는 결함의 종류를 미리 체크리스트로 정리, 배포
- 결함 찾는 방법
  1. 코드에 존재하는 결함으로 나타날 비정상적인 패턴이나, 원하지 않는 패턴을 찾아내는 방법
    - 자료 흐름이나 논리 후름을 분석하는 것
    - 자료 흐름 : 자료가 어디서 정의되고, 어디서 사용되었는지를 나타내는 그래프 
    - 자료 변칙: 자료 흐름도를 분석하여 자료의 비상적인 패턴을 찾는것
    - 사용된 변수가 정의되었는지를 확인 : 제어경로를 따라 올라가 def집합에 있는지 조사
    - 정의되었지만, 사용되지 않는 변수 확인 : 정의된 노트로부터 아래 경로 추적, use집합에 있는지 조사
  2. 실행할 때 프로그램의 고장을 일으킬 코드상에 존재하는 결합을 직접찾는 방법
    - 결함 검출: 프로그램에 있는 불필요한 부분을 검출
  
### 9-5-3 테스트 중심 개발
- 일반적 : 프로그램 작성 후 테스팅
- 테스트 중심 개발 - 테스트를 위한 코드를 작성 후 기능 구현
- 개발과정
  1. TDD 개발 
    - 개발하려는 프로그램의 뼈대
    - 테스트 커버리지 수준을 결정
  2. 테스트 코드 작성
    - 구현할 기능을 선정& 기능을 테스트할 방법을 설계하고 코딩
    - 테스트 하려는 대상을 셋업&구동 후 결과를 비교하는 명령으로 구성
  3. 반복하여 기능을 구현하고 테스트
    - 미리 작성한 코드에 의하여 통과될 수 있도록 기능을 조금씩 정확하게 구현
    - 구현된 기능을 테스트
    - 테스트를 통과할 때 까지 코드 발전& 테스트 수행 반복
  4. 테스트 커버리지 측정
    - 테스트가 수행되어 프로그램 실행이 확인된 비율 측정 & 수준 미달일시 테스트 케이스 추가
    - 추가된 테스트 코드를 사용하여 프로그램 테스팅 -> 원하는 수준의 커버리지 도달 > 테스트 종료 

- 테스트 코드
  - 클래스의 메서드를 시험하는 단위 테스트 목적을 가지고 있음  
  - 메서드 구동을 위해 객체 생성 -> 테스트 준비 코드, 메서드 실행 코드, 결과/예상 비교 코드로 구성

- 짝 프로그래밍
- 두사람이 같은 컴퓨터를 사용하면서 다른역할(개발/테스팅)을 함
- 장점
  - 프로그래밍에 재미 + 스트레스 줄일 수 있음
  - 파트너와 아이디어 공유 > 팀의 소통 향샹
  - 구성원간의 이해와 렵력이 향상
  - 효율적인 해법을 만들어 낼 수 있음
 - 단점
  - 혼자 작업하는 것을 좋아하는 프로그래머에게 적합x
  - 잘 다루지 못하면 파트너와의 대화 시간이 너무 많이 걸림 - 대화는 문제해결, 작업완성에 초점
  - 파트너와의 차이점에 적응하기 위해 시간이 걸릴 수 있음
  - 결함 발견에서 인스펙션과 같은 체계적인 리뷰만큼 효과적이지 않을 수 있음
