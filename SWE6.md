# 설계원리
## 목차
1. [설계 기본 개념과 과정은 무엇인가?](#설계-기본-작업-개념과-과정)
2. [설계 작업에 고려하여야 할 품질 목표에는 어떤 것들이 있는가?](#설계-작업에-고려하여야-할-품질-목표)
3. [전통적인 설계 원리는 어떤 것들이 있는가?](#전통적인-설계원리)
4. [객체지향 패러다임의 설계 원리(SOLID)는 무엇인가?](#객체지향-패러다임의-설계-원리)
5. [설계 결과를 객관적으로 측정하는 방법은 무엇인가?](#설계-결과-객관적으로-측정-방법)

요구 분석 - 무엇을 담을 것인가?
설계 - 요구사항을 어떻게 실현할 것인가?
기본 구조 설계 - 아키텍쳐 설계로 각 모듈의 역할과 인터페이스를 정의한다
상세 설계 - 모듈 내부의 알고리즘, 데이터를 명세화한다
분석과 설계 ( 출처 - 소프트웨어 공학의 모든 것 233page )
 
### 설계-기본-작업-개념과-과정
6-1. 설계 기본 개념
설계 - 높은 수준의 의사 결정 과정의 연속

전통적 방법
분할 정복
추상화
합성
최근의 방법

아키텍쳐 기반 설계
복잡한 문제를 다룰 수 있고, 변경에 대처하기 좋음
 

6-1-1. 서브시스템, 모듈

 

아키텍처 - 시스템을 구성하는 컴포넌트와 컴포넌트 상호작용의 집합

 

서브시스템 - 시스템의 복잡도를 줄이기 위해 분할한 것(개발자 커뮤니케이션, 수정에 대한 영향 감소)


서브시스템 ( 출처 - 소프트웨어 공학의 모든 것 235page )
복잡한 시스템은 서브시스템을 반복적으로 분할하여 계층화 할 수 있음

 

 	컴포넌트	모듈	서브시스템
개념	- 명백한 역할을 가지고 있으며 독립적으로 존재할 수 있는 시스템의 부분
- 같은 기능을 가진 컴포넌트로 대체 가능함
- 재사용이 가능하게 설계됨
- 특정 목적(시스템의 사용자 인터페이스 제공)을 수행하는 경우도 있음	- 프로그래밍 언어의 문법구조에서 정의된 컴포넌트를 의미
- 모듈은 구체적인 프로그래밍 언어로 작성된 문법 단위로 한정하여 사용
- ex> 클래스, 메서드, 패키지는 Java 프로그램의 모듈이며, 함수, 파일은 C언어의 모듈임	- 여러 다른 방법들로 구현될 객체
- 컴포넌트, 모듈보다는 더 추상적
- 정의 가능한 책임과 목적을 가지며, 소프트웨어나 하드웨어로 구성된 논리적 개체
- 컴포넌트들이 변하거나 교체되더라도 지속적으로 존재함
- 큰 시스템의 일부분으로 유한한 인터페이스를 가짐
 

6-1-2. 설계 관점

 

 

아키텍쳐 설계에서의 세 가지 관점

모듈 관점 - 일정 책임을 구현한 코드 단위인 모듈과 그 관계로 소프트웨어 구조를 설명함
컴포넌트 관점 - 실행될 때 동작하는 요소와 상호작용으로 구조를 설명 ( 더 추상화 )
할당 관점 - 소프트웨어 하드웨어 설치, 작업 할당, 구현, 데이터 저장 등에 대한 관점
 

설계 관점과 표현 방법 ( 출처 - 소프트웨어 공학의 모든 것 237page )

측면	설계 스타일	표현 방법
모듈 측면	분할, 사용 관계, 계층 구조, 데이터 모델	

컴포넌트 측면	클라이언트 서버
파이프 필터
출판 구독
이벤트 중심
리파지토리


할당 측면	배치, 설치, 작업 할당, 구현, 데이터 저장	

 

6-1-3. 설계 작업 과정

 

설계 작업 - 의사 결정 과정이면서 동시에 시스템을 알아가는 과정

 

시스템 유형을 고려하는 것이 가장 중요 -> 아키텍처 스타일 선택에 영향을 주기 때문

 


아키텍처 설계 과정 ( 출처 - 소프트웨어 공학의 모든 것 238page )
아키텍쳐 설계 과정

 

1. 설계 목표 설정

전체 시스템에 대한 설계 목표를 파악, 결정
ex > 전화 교환 시스템을 개발한다고 하면 고장에 대한 내성, 안전과 보안, 최대 성능이 설계 목표가 될 수 있음
2. 스타일 결정

시스템 또는 서브시스템의 타입을 결정하기 위해 설계 목표, 유형에 맞는 아키텍쳐 스타일을 결정함
적용 가능한 아키텍쳐 스타일이 있다면 적용하고, 없다면 맞춤형 아키텍쳐 스타일을 설계한다
3. 서브시스템의 기능, 인터페이스 명세

서브시스템 사이의 인터페이스 정의, 서브시스템 사이의 상호작용을 위한 동작 작성
4. 아키텍처 설계 검토

아키텍처가 요구, 설계 목표, 설계 원리를 잘 만족하는지 검토
 

 

6-2. 품질 목표

 

 

기능 요구에 대한 요구 분석 모델은 하나이다.

 

비기능 요구(품질 요구사항)에 대한 설계안은 여러 가지가 있을 수 있다.

 

따라서 요구 분석에서 찾은 비기능적 요구를 설계 목표로 명시하고 이를 만족하기 위한 설계안을 만들고 그 중에 최적안을 골라내야 한다.

 


설계와 품질 목표 ( 출처 - 소프트웨어 공학의 모든 것 240page )
 

품질 요구사항을 충족하게끔 설계할 때는 다른 속성에 미치는 영향을 고려하여 설계하여야 한다.

 

품질 속성의 우선순위를 정하고 상반되는 요구에 대한 절충안을 찾는 것이 중요함

 

 

ISO 25010에서 정의한 소프트웨어 기능 외적인 품질

( 출처 - 소프트웨어 공학의 모든 것 240~241pages )

품질 특성	설명	측정 방법, 속성
성능	- 성능은 일정 시간 동안 특정 작업을 수행하는 시스템의 응답속도
- 성능 문제는 서버의 용량, 프론트 엔드 개발 방법에서부터 데이터베이스 쿼리 효율성 또는 통신 채널 용량에 이르기까지 모든 것에 영향을 미칠 수 있는 요소임	- 단위 시간당 평균/최대 사용자 수
- 화면 불러오는 평균 시간
- 평균 실행시간
상호운용성	- 운영이나 다른 외부 시스템과의 데이터 전송, 교환을 담당하는 시스템의 속성
- 잘 설계된 시스템은 타사 시스템과의 통합이 쉬움
- 상호 운용성 향상을 위해서는 외부 인터페이스를 잘 설계하고 시스템을 표준화 해야 함	- 지원하는 장치, OS 버전, 화면 해상도, 브라우저의 리스트
사용용이성	- 사용자가 시스템을 효율적으로 사용하여 만족스러운 정도를 나타내는 시스템의 속성
- 사용자가 작업을 수행하는 데 필요한 너무 많은 상호작용, 동작, 다단계 인터페이스는 비효율적
- 데이터 요소나 컨트롤이 사용자 경험에 익숙한 패턴에 따라 설계하지 않으면 상호작용이 복잡하게 됨	- UI 가속화 요소
- 사용자 요구 수행 평균 시간
신뢰성	- 시스템이 정의된 조건 아래 계속 작동할 수 있는 능력
- 데이터베이스, 다른 시스템 및 네트워크 연결과 같은 외부 요소에 엑세스 할 수 없기 때문에 실패하는 경우가 많음	- 가용률
- 다운된 시간
- 소프트웨어 결함
보안성	- 악의적이거나 우발적인 행동의 가능성을 줄이기 위한 시스템의 특성
- 시스템을 보호하기 위해 인증, 암호화, 감사 등 여러 가지 초치가 사용됨 	- 기밀유지성
- 책임성
- 권한인증성
유지보수성	- 변경에 대하여 얼마나 잘 수용하는지 나타내는 특성
- 변경 사항은 새로운 비즈니스 요구사항 또는 오래된 오류수정이며 시스템 구성 요소나 실행 방법에 영향을 줄 수 있음
- 장애가 발생한 후 시스템을 복원하는 데 필요한 시간에 영향을 줌
- 구성 요소 사이에 과도하게 종속되면 유지보수성은 떨어짐	- 모듈화
- 재사용성
- 변경가능성
- 테스트가능성
이식성	- 하드웨어, 소프트웨어, 사용 환경에서 시스템이나 구성 요소를 다른 곳으로 쉽게 변환할 수 있는 특성	- 적응성
- 설치가능성
- 대체가능성
 

 

6-3. 전통적인 설계 원리

 

소프트웨어 설계에서 전통적으로 중요하게 생각하는 요소

효율성 - 시스템이 사용하는 자원이 적정한가?
단순성 - 얼마나 단순한가? ( 유지보수성에 영향을 주는 가장 중요한 특성 )

전통적인 설계 원리 ( 출처 - 소프트웨어 공학의 모든 것 242page )
 

 

6-3-1. 추상화

 

추상화

컴포넌트 구현에 대한 자세한 사항을 염려하지 않고 추상적인 수준으로 컴포넌트를 다루는 도구
대상에 대하여 특정한 목적에 관련된 정보에 집중하고 나머지 정보는 무시하는 관점
데이터나 절차적인 동작 관점으로 정의할 수 있다
복잡성을 줄이고 복잡한 소프트웨어 시스템을 효율적으로 다루고 구현할 수 있음
존재하는 컴포넌트의 추상은 유지보수에 중요한 역할을 함

자료 및 절차 추상화 ( 출처 - 소프트웨어 공학의 모든 것 243page )
 

6-3-2. 캡슐화

 

추상화된 대상이 제공하는 서비스를 쉽게 접근하게 하는 개념

 

정보은닉

내부에 데이터를 어떻게 저장하는지, 어떻게 처리하는 지, 특정 기능을 어떻게 제공하는지 드러나지 않음
정보은닉이 잘 되면 숨겨진 부분에 대한 변경 사항이 외부 내용에 영향을 주지 않음 -> 소프트웨어 변경 요구에 탄력적인 대처 가능

캡슐화 ( 출처 - 소프트웨어 공학의 모든 것 245page )
위 그림에서 TV 기능을 상호 작용할 수 있는 리모콘으로 추상화 했다고 해 보자

 

그림에서와 같이 신호 디코딩과 같은 자세한 정보를 나타낼 필요가 없다. 리모콘의 핵심 기능인 채널, 볼륨, 전원 상태를 나타내는 데이터 등을 묶어 캡슐화 하면 된다.

 

객체지향 언어를 사용하게 되면 정보를 접근할 수 있는 권한을 정의할 수 있다.(private,public,protected)

 

 

6-3-3. 모듈화

 

모듈화

소프트웨어를 작은 구성 요소, 즉 패키지 또는 클래스로 나누는 것

모듈화의 수준 ( 출처 - 소프트웨어 공학의 모든 것 245page )
 

장점

필요한 부분의 수정, 재사용이 용이함(모듈을 수정해도 일부만 컴파일을 할 수 있기 때문)
시스템의 문제를 국한(한정)시키며 시스템을 고치는 작업도 수월하게 가능함
단점

너무 많은 모듈화가 있으면 상호작용에 문제가 생길 수 있음
 

+ 추상, 캡슐, 모듈화의 관계

 

추상화	캡슐화	모듈화
시스템의 핵심 특성에 초점을 두어 하나의 큰 시스템을 분할	분할된 핵심 정보만을 노출	적절한 수준으로 분할하여 독립적인 모듈로 구성해야 함

추상화, 캡슐화, 모듈화의 관계 ( 출처 - 소프트웨어 공학의 모든 것 246page )
 

6-3-4. 결합(Coupling)

 

모듈 간에 서로 의존하는 정도

 

결합이 강하면

이해하기 어려움
변경시 파급 효과가 크다 (하나의 모듈이 잘못되면 오류가 전파되기 때문)
디버깅, 결함 수정이 어려움
 

모듈간 결합 정도 결정 요인

모듈 간 인터페이스 수
각 인터페이스의 복잡성(통신 유형에 따라 결정)

모듈 사이의 결합 ( 출처 - 소프트웨어 공학의 모든 것 247page )
 

결합의 종류

 

- 내용 결합

한 모듈이 다른 모듈의 내용을 직접 참조
예를 들어 P라는 모듈이 Q라는 모듈의 문장을 조작, 로컬 데이터 값 참조, Q의 내부로 분기하는 경우
- 공통 결합

한 모듈이 다른 모듈이 읽은 전역 변수 값을 쓰거나 변경
매개변수 대신 전역변수를 이용하여 데이터를 교환하는 경우
- 제어 결합

한 모듈이 다른 모듈의 제어흐름 경로를 결정
예를 들어 print 함수는 흐름 경로가 설정되어 있다. 즉, print함수가 정의된 모듈은 print를 호출하는 모듈의 흐름 경로를 결정한 것이니 제어 결합으로 의존되어 있다.
- 스탬프 결합

복합 데이터 구조의 일부만 사용하는 모듈에 복합 데이터 구조를 전달할 때
예를 들면 세 개의 필드가 있는 레코드를 처음 두 개의 필드만 모듈에 매개변수로 전달하는 경우
- 데이터 결합

모듈들이 주고 받는 매개변수가 간단한 타입이거나 레코드 안의 필드이더라도 단순 타입인 경우
 

 

6-3-5. 응집(Cohesion)

 

 

하나의 모듈 안에서 수행되는 작업들이 서로 관련된 정도

 

= 모듈 안의 여러 요소들이 특정 작업을 수행하기 위해 함께 잘 모여 있는지를 나타냄

 

 

높은 응집일때는?

재사용하기도 쉽고 이해하기 좋다
수정에 의하여 받는 영향이 적다

모듈의 응집 정도 ( 출처 - 소프트웨어 공학의 모든 것 249page )
여러 가지 응집들

 

- 우연적 응집

가장 응집이 약한 형태
단위 안의 요소들이 의미적으로 아무 관계가 없는 응집
- 논리적 응집

본직적으로 다르더라도 같은 범주의 기능을 수행하므로 논리적으로 분류되기 때문에 묶인 경우
예를 들어 마우스 및 키보드 입력 처리 루틴
- 시간적 응집

프로그램 실행의 특정한 시간에 처리되므로 한 그룹 안에 모여 있는 경우
- 절차적 응집

모듈 안에서 수행되는 연산이 프로그램에서 수행되는 순서와 관련이 있는 경우
예를 들어 모듈 안에서 "A라는 작업 뒤에 B작업을 한다"와 같이 순차적으로 정의되는 경우
- 교환적 응집

모듈의 내부 요소들이 동일한 데이터를 조작하기 때문에 그룹화 된 경우
예를 들어 동일한 레코드에 대해 작동하는 오퍼레이션들이 하나의 모듈 안에 모아진 경우
- 기능적 응집

하나의 기능에 모두 기여하고 밀접하게 관련하고 있는 경우
기능에 꼭 필요한 요소들만 모여 있을때!!
- 정보적 응집

각 오퍼레이션들은 각각 고유한 시작점과 독립된 코드가 있고 모든 오퍼레이션이 같은 데이터에 대해 실행됨
객체지향 패러다임에서는 자연스레 가지는 응집 ( 각 객체에 자체 소스 코드와 파일이 있으며, 각 객체 안에서 정의된 데이터를 조작함 )
 

+ 좋은 소프트웨어가 되려면?

 

좋은 소프트웨어가 되기 위해서는 모듈 간의 결합은 낮은 결합 형태를 가지며, 모듈 속에서는 높은 응집도를 가져야 한다.

 

 

높은 응집과 낮은 결합

응집 - 모듈, 클래스, 컴포넌트 안에 있는 요소들이 하나의 기능 단위로써 협동하는 정도


결합 - 둘 이상의 모듈, 클래스 컴포넌트 사이에 서로 의존하는 정도



높은 응집력 - 코드의 단위 안의 요소들이 서로 관련 있는 것을 한 곳에 넣고 유지하는 것을 의미함

낮은 결합력 - 코드의 단위 안에서 관련 없는 요소들을 가능한 많이 분리해 내는 것
 

그렇다면 응집력을 높게, 결합력을 낮게 하기 위해서는 어떻게 해야 되는가?

 

- 응집을 높이는 방법

 

단일 책임을 가지게 하면 모듈 안의 응집력이 높아진다.

 

모듈의 기능을 한마디로 요약할 수 없다면 응집력이 떨어지는 것임

 

모듈의 기능을 정의한 문장을 밑에 있는 표로 분석하여 하나 이상의 기능을 수행한다는 결론이 나게 되면 분할을 진행하여 준다.

 

예를 들어 어떤 자료를 가지고 있는 모듈이 이미지를 처리하는 기능과 사운드를 처리하는 기능을 함께 가지고 있다고 하면 그 모듈은 응집력이 낮은 것이다.

 

따라서 자료를 보관하는 모듈을 분할하여 이미지 처리 모듈, 사운드 처리 모듈을 독립시킨다.
