# 설계원리
## 목차
1. [설계 기본 개념과 과정은 무엇인가?](#설계-기본-작업-개념과-과정)
2. [설계 작업에 고려하여야 할 품질 목표에는 어떤 것들이 있는가?](#설계-작업에-고려하여야-할-품질-목표)
3. [전통적인 설계 원리는 어떤 것들이 있는가?](#전통적인-설계원리)
4. [객체지향 패러다임의 설계 원리(SOLID)는 무엇인가?](#객체지향-패러다임의-설계-원리)
5. [설계 결과를 객관적으로 측정하는 방법은 무엇인가?](#설계-결과-객관적으로-측정-방법)

요구 분석 - 무엇을 담을 것인가?
설계 - 요구사항을 어떻게 실현할 것인가?
기본 구조 설계 - 아키텍쳐 설계로 각 모듈의 역할과 인터페이스를 정의한다
상세 설계 - 모듈 내부의 알고리즘, 데이터를 명세화한다
분석과 설계 ( 출처 - 소프트웨어 공학의 모든 것 233page )
 
### 설계-기본-작업-개념과-과정
#### 6-1. 설계 기본 개념
설계 - 높은 수준의 의사 결정 과정의 연속

전통적 방법
-분할 정복
-추상화
-합성

최근의 방법
-아키텍쳐 기반 설계
-복잡한 문제를 다룰 수 있고, 변경에 대처하기 좋음
 
#### 6-1-1. 서브시스템, 모듈
아키텍처 - 시스템을 구성하는 컴포넌트와 컴포넌트 상호작용의 집합
서브시스템 - 시스템의 복잡도를 줄이기 위해 분할한 것(개발자 커뮤니케이션, 수정에 대한 영향 감소)
![image](https://user-images.githubusercontent.com/64974683/197344355-c3e7c7a9-9921-44ab-8081-7ac65bdb35ee.png)

복잡한 시스템은 서브시스템을 반복적으로 분할하여 계층화 할 수 있음
<table>
<tr><td>컴포넌트</td><td>모듈</td><td>서브시스템</td></tr>
<tr><td>- 명백한 역할을 가지고 있으며 독립적으로 존재할 수 있는 시스템의 부분<br>
- 같은 기능을 가진 컴포넌트로 대체 가능함<br>
- 재사용이 가능하게 설계됨<br>
- 특정 목적(시스템의 사용자 인터페이스 제공)을 수행하는 경우도 있음<br></td><td>
- 프로그래밍 언어의 문법구조에서 정의된 컴포넌트를 의미<br>
- 모듈은 구체적인 프로그래밍 언어로 작성된 문법 단위로 한정하여 사용<br>
- ex> 클래스, 메서드, 패키지는 Java 프로그램의 모듈이며, 함수, 파일은 C언어의 모듈임</td><td>
- 여러 다른 방법들로 구현될 객체<br>
- 컴포넌트, 모듈보다는 더 추상적<br>
- 정의 가능한 책임과 목적을 가지며, 소프트웨어나 하드웨어로 구성된 논리적 개체<br>
- 컴포넌트들이 변하거나 교체되더라도 지속적으로 존재함<br>
- 큰 시스템의 일부분으로 유한한 인터페이스를 가짐</td><td></tr>
</table>
 
#### 6-1-2. 설계 관점
아키텍쳐 설계에서의 세 가지 관점
-모듈 관점 - 일정 책임을 구현한 코드 단위인 모듈과 그 관계로 소프트웨어 구조를 설명함
-컴포넌트 관점 - 실행될 때 동작하는 요소와 상호작용으로 구조를 설명 ( 더 추상화 )
-할당 관점 - 소프트웨어 하드웨어 설치, 작업 할당, 구현, 데이터 저장 등에 대한 관점

![image](https://user-images.githubusercontent.com/64974683/197345492-2ae6f72c-1295-48f1-95fe-32c87ae63506.png)

#### 6-1-3. 설계 작업 과정
설계 작업 - 의사 결정 과정이면서 동시에 시스템을 알아가는 과정
시스템 유형을 고려하는 것이 가장 중요 -> 아키텍처 스타일 선택에 영향을 주기 때문
![image](https://user-images.githubusercontent.com/64974683/197345509-e2f181c5-ef45-45c5-8ce1-47bd0233b918.png)

아키텍쳐 설계 과정
1. 설계 목표 설정
전체 시스템에 대한 설계 목표를 파악, 결정
ex > 전화 교환 시스템을 개발한다고 하면 고장에 대한 내성, 안전과 보안, 최대 성능이 설계 목표가 될 수 있음

2. 스타일 결정
시스템 또는 서브시스템의 타입을 결정하기 위해 설계 목표, 유형에 맞는 아키텍쳐 스타일을 결정함
적용 가능한 아키텍쳐 스타일이 있다면 적용하고, 없다면 맞춤형 아키텍쳐 스타일을 설계한다

3. 서브시스템의 기능, 인터페이스 명세
서브시스템 사이의 인터페이스 정의, 서브시스템 사이의 상호작용을 위한 동작 작성

4. 아키텍처 설계 검토
아키텍처가 요구, 설계 목표, 설계 원리를 잘 만족하는지 검토
 
### 6-2. 품질 목표
기능 요구에 대한 요구 분석 모델은 하나이다.
비기능 요구(품질 요구사항)에 대한 설계안은 여러 가지가 있을 수 있다.

따라서 요구 분석에서 찾은 비기능적 요구를 설계 목표로 명시하고 이를 만족하기 위한 설계안을 만들고 그 중에 최적안을 골라내야 한다.
![image](https://user-images.githubusercontent.com/64974683/197345540-c0be6314-6f7f-4102-a73d-b211164fb79b.png)
 
품질 요구사항을 충족하게끔 설계할 때는 다른 속성에 미치는 영향을 고려하여 설계하여야 한다.
품질 속성의 우선순위를 정하고 상반되는 요구에 대한 절충안을 찾는 것이 중요함

ISO 25010에서 정의한 소프트웨어 기능 외적인 품질
![image](https://user-images.githubusercontent.com/64974683/197345590-8f075d3d-7b59-4d5e-879f-26039f05f36d.png)

### 6-3. 전통적인 설계 원리
소프트웨어 설계에서 전통적으로 중요하게 생각하는 요소
-효율성 - 시스템이 사용하는 자원이 적정한가?
-단순성 - 얼마나 단순한가? ( 유지보수성에 영향을 주는 가장 중요한 특성 )

![image](https://user-images.githubusercontent.com/64974683/197345601-e8209342-1319-4caf-97d7-77aa6c08c7d9.png)

#### 6-3-1. 추상화
추상화
-컴포넌트 구현에 대한 자세한 사항을 염려하지 않고 추상적인 수준으로 컴포넌트를 다루는 도구
-대상에 대하여 특정한 목적에 관련된 정보에 집중하고 나머지 정보는 무시하는 관점
-데이터나 절차적인 동작 관점으로 정의할 수 있다
-복잡성을 줄이고 복잡한 소프트웨어 시스템을 효율적으로 다루고 구현할 수 있음
-존재하는 컴포넌트의 추상은 유지보수에 중요한 역할을 함

![image](https://user-images.githubusercontent.com/64974683/197345625-391cfb34-88f8-43a2-b23e-17f8ee6c1c46.png)
 
#### 6-3-2. 캡슐화
추상화된 대상이 제공하는 서비스를 쉽게 접근하게 하는 개념

정보은닉

내부에 데이터를 어떻게 저장하는지, 어떻게 처리하는 지, 특정 기능을 어떻게 제공하는지 드러나지 않음
정보은닉이 잘 되면 숨겨진 부분에 대한 변경 사항이 외부 내용에 영향을 주지 않음 -> 소프트웨어 변경 요구에 탄력적인 대처 가능

객체지향 언어를 사용하게 되면 정보를 접근할 수 있는 권한을 정의할 수 있다.(private,public,protected)

#### 6-3-3. 모듈화
모듈화
소프트웨어를 작은 구성 요소, 즉 패키지 또는 클래스로 나누는 것
![image](https://user-images.githubusercontent.com/64974683/197345656-668e2420-da1c-4efa-a91a-eaaccb9259ae.png)
 
장점
필요한 부분의 수정, 재사용이 용이함(모듈을 수정해도 일부만 컴파일을 할 수 있기 때문)
시스템의 문제를 국한(한정)시키며 시스템을 고치는 작업도 수월하게 가능함

단점
너무 많은 모듈화가 있으면 상호작용에 문제가 생길 수 있음
 
+ 추상, 캡슐, 모듈화의 관계

추상화	캡슐화	모듈화
시스템의 핵심 특성에 초점을 두어 하나의 큰 시스템을 분할	분할된 핵심 정보만을 노출	적절한 수준으로 분할하여 독립적인 모듈로 구성해야 함
![image](https://user-images.githubusercontent.com/64974683/197345668-6a0b7046-c266-49df-87ef-945627617e0e.png)
 
#### 6-3-4. 결합(Coupling)
모듈 간에 서로 의존하는 정도

결합이 강하면
-이해하기 어려움
-변경시 파급 효과가 크다 (하나의 모듈이 잘못되면 오류가 전파되기 때문)
-디버깅, 결함 수정이 어려움
 
모듈간 결합 정도 결정 요인
-모듈 간 인터페이스 수
-각 인터페이스의 복잡성(통신 유형에 따라 결정)
![image](https://user-images.githubusercontent.com/64974683/197345680-647204f8-a9b8-4436-8876-ead85b23b363.png)
 
결합의 종류
- 내용 결합
한 모듈이 다른 모듈의 내용을 직접 참조
예를 들어 P라는 모듈이 Q라는 모듈의 문장을 조작, 로컬 데이터 값 참조, Q의 내부로 분기하는 경우

- 공통 결합
한 모듈이 다른 모듈이 읽은 전역 변수 값을 쓰거나 변경
매개변수 대신 전역변수를 이용하여 데이터를 교환하는 경우

- 제어 결합
한 모듈이 다른 모듈의 제어흐름 경로를 결정
예를 들어 print 함수는 흐름 경로가 설정되어 있다. 즉, print함수가 정의된 모듈은 print를 호출하는 모듈의 흐름 경로를 결정한 것이니 제어 결합으로 의존되어 있다.

- 스탬프 결합
복합 데이터 구조의 일부만 사용하는 모듈에 복합 데이터 구조를 전달할 때
예를 들면 세 개의 필드가 있는 레코드를 처음 두 개의 필드만 모듈에 매개변수로 전달하는 경우

- 데이터 결합
모듈들이 주고 받는 매개변수가 간단한 타입이거나 레코드 안의 필드이더라도 단순 타입인 경우
 
#### 6-3-5. 응집(Cohesion)
하나의 모듈 안에서 수행되는 작업들이 서로 관련된 정도
= 모듈 안의 여러 요소들이 특정 작업을 수행하기 위해 함께 잘 모여 있는지를 나타냄

높은 응집일때는?
-재사용하기도 쉽고 이해하기 좋다
-수정에 의하여 받는 영향이 적다
![image](https://user-images.githubusercontent.com/64974683/197345742-2b558666-c1bb-4bd6-b102-172deddc211f.png)

여러 가지 응집들
- 우연적 응집
가장 응집이 약한 형태
단위 안의 요소들이 의미적으로 아무 관계가 없는 응집

- 논리적 응집
본직적으로 다르더라도 같은 범주의 기능을 수행하므로 논리적으로 분류되기 때문에 묶인 경우
예를 들어 마우스 및 키보드 입력 처리 루틴

- 시간적 응집
프로그램 실행의 특정한 시간에 처리되므로 한 그룹 안에 모여 있는 경우

- 절차적 응집
모듈 안에서 수행되는 연산이 프로그램에서 수행되는 순서와 관련이 있는 경우
예를 들어 모듈 안에서 "A라는 작업 뒤에 B작업을 한다"와 같이 순차적으로 정의되는 경우

- 교환적 응집
모듈의 내부 요소들이 동일한 데이터를 조작하기 때문에 그룹화 된 경우
예를 들어 동일한 레코드에 대해 작동하는 오퍼레이션들이 하나의 모듈 안에 모아진 경우

- 기능적 응집
하나의 기능에 모두 기여하고 밀접하게 관련하고 있는 경우
기능에 꼭 필요한 요소들만 모여 있을때!!

- 정보적 응집
각 오퍼레이션들은 각각 고유한 시작점과 독립된 코드가 있고 모든 오퍼레이션이 같은 데이터에 대해 실행됨
객체지향 패러다임에서는 자연스레 가지는 응집 ( 각 객체에 자체 소스 코드와 파일이 있으며, 각 객체 안에서 정의된 데이터를 조작함 )
 
+ 좋은 소프트웨어가 되려면?
좋은 소프트웨어가 되기 위해서는 모듈 간의 결합은 낮은 결합 형태를 가지며, 모듈 속에서는 높은 응집도를 가져야 한다.

높은 응집과 낮은 결합
응집 - 모듈, 클래스, 컴포넌트 안에 있는 요소들이 하나의 기능 단위로써 협동하는 정도
결합 - 둘 이상의 모듈, 클래스 컴포넌트 사이에 서로 의존하는 정도
높은 응집력 - 코드의 단위 안의 요소들이 서로 관련 있는 것을 한 곳에 넣고 유지하는 것을 의미함
낮은 결합력 - 코드의 단위 안에서 관련 없는 요소들을 가능한 많이 분리해 내는 것
 
그렇다면 응집력을 높게, 결합력을 낮게 하기 위해서는 어떻게 해야 되는가?

- 응집을 높이는 방법

단일 책임을 가지게 하면 모듈 안의 응집력이 높아진다.
모듈의 기능을 한마디로 요약할 수 없다면 응집력이 떨어지는 것임
모듈의 기능을 정의한 문장을 밑에 있는 표로 분석하여 하나 이상의 기능을 수행한다는 결론이 나게 되면 분할을 진행하여 준다.
예를 들어 어떤 자료를 가지고 있는 모듈이 이미지를 처리하는 기능과 사운드를 처리하는 기능을 함께 가지고 있다고 하면 그 모듈은 응집력이 낮은 것이다.

따라서 자료를 보관하는 모듈을 분할하여 이미지 처리 모듈, 사운드 처리 모듈을 독립시킨다.

응집력을 판단하는 기준
![image](https://user-images.githubusercontent.com/64974683/197345825-6a519cef-2ede-4ea0-9c2c-b24a0d36ae18.png)
 
- 결합을 낮추는 방법
결합을 낮추기 위해서는 모듈 사이의 인터페이스 수를 줄이고, 각 인터페이스의 복잡도를 낮추어야 한다.
그리고 간단한 정보를 파라미터로 넘겨야 하며, 데이터를 전달하는 커뮤니케이션을 진행하여야 한다.
![image](https://user-images.githubusercontent.com/64974683/197345844-09054c1a-e03a-4326-9d07-f35247a3b040.png)
 

### 6-4. 객체지향 설계 원리(SOLID)
전통적인 설계 원리는 객체지향 개념(상속, 인터페이스 등)이 추가 되어 재사용, 수정 용이성 등의 품질을 높일 수 있게 되었으며 이를 위해 지켜야 할 5가지의 원리가 있다.

-단일 책임의 원리 (Single Responsibility Principle)
-개방 폐쇄의 원리 (Open Close Principle)
-리스코프 교체의 원리 (Liskov Substitution Principle)
-인터페이스 분리의 원리 (Interface Segregation Principle)
-의존관계 역전의 원리 (Dependency Inversion Principle)
 
#### 6-4-1. 인터페이스와 구현의 분리
인터페이스 - 메서드의 프로토타입만을 정해 놓은 것
공개된 메서드를 인터페이스로 따로 정의 후 이를 구현, 상속한다.

인터페이스와 구현의 분리 원칙
컴포넌트의 공개 인터페이스(컴포넌트의 사용자가 알아야 할 부분)를 컴포넌트가 어떻게 구현되는지 상세하게 나타낸 것과 분리!
![image](https://user-images.githubusercontent.com/64974683/197345877-078318a1-e101-42e3-b3a5-e78e41623d6e.png)
 
#### 6-4-2. 단일 책임의 원리 (Single Responsibility Principle)
클래스의 역할과 책임을 단일화 하여 클래스를 변경해야 할 이유를 하나로 제한시키는 원리
![image](https://user-images.githubusercontent.com/64974683/197345893-a28ef300-29ab-4b3c-8391-0533b4996de4.png)

Book에 책 이름, 저자, 내용을 관리하고 저장해야 하는 책임이 있다고 해 보자
여기서 Book은 다른 매체에 Print를 해 주면서 해상도 등을 고려해야 함
즉, Book은 내용을 관리하고 저장해야 하는 책임과 다른 곳에 Print를 하게 하는 두 가지의 책임이 있다.

>> 책임 분리를 해 줘야됨!

#### 6-4-3. 개방 폐쇄의 원리 (Open Close Principle)
소프트웨어 개체(클래스, 모듈, 기능 등) 가 확장을 위해서는 열려 있어야 하지만 수정을 위해서는 닫혀야 한다
상속을 이용하여 클래스가 정의되어 있을 때는 다형성이 적용되어 서로 대체할 수 있는 인터페이스를 구현 할 수 있다.

![image](https://user-images.githubusercontent.com/64974683/197345916-f93c1162-9216-4eb5-9eae-f94640bc5c5b.png)

SortAlgorithm을 이용하는 Client 프로그램이 있다고 하면 SortAlgorithm을 상속 받은 여러 정렬 알고리즘들은 다형성을 이용하여 확장할 수 있도록 열려있다.
상속 관계가 아니라면 접근을 할 수 없기에 Client는 SortAlgorithm을 수정할 수 없음을 알 수 있다. ( 수정에 닫힘 )

#### 6-4-4. 리스코프 교체의 원리 (Liskov Substitution Principle)
클래스 B가 클래스 A에게서 상속받는 클래스라고 하면 A를 B로 대체할 수 있어야 한다는 원리이다.
즉, 파생 클래스가 부모 클래스로 대체 가능해야 한다.. 는 것이다.

![image](https://user-images.githubusercontent.com/64974683/197345946-648535ae-ea91-4874-9649-7fe20c2a7b85.png)
위 사례는 위반 사례이다.

여기서 리스코프 교체의 원리에 따르면 MuteMouse가 Animal을 대체 가능하다는 것인데
조건이 있다.
교체하려는 하위 클래스에서 오버라이딩 된 메서드들이 모두 타당하게 구현이 되어야 한다는 점이다.

예를 들어 위 사진처럼 MuteMouse의 makeNoise()가 IMakeNoiseException을 던지게 되면 리스코프 교체의 원리에 위배된다. ( 타당하게 구현되지 않은 것이다. )

이 점을 주의할 것!

#### 6-4-5. 인터페이스 분리의 원리 (Interface Segregation Principle)
클라이언트가 사용하지 않는 인터페이스를 강제로 구현해서는 안됨
> 당연한거 아닌가.. 필요 없는 것도 오버라이딩을 해 줘야 하기 때문
사용하지 않는 인터페이스를 비만 인터페이스(fat), 오염된 인터페이스(polluted) 라고 한다.

![image](https://user-images.githubusercontent.com/64974683/197345983-be04b192-6010-4216-92ab-da569b595697.png)
왼쪽 그림에서 새는 필요없는 walk()를 만들어야 하는 사태가 발생한다.

#### 6-4-6. 의존 관계 역전의 원리 (Dependency Inversion Principle)
구체화 된 모듈이 추상화 된 모듈에게 의존이 역전되도록 설계하는 것
즉, 추상화 된 모듈이 구체화 된 모듈에 의존하면 안된다. 
구체화 된 모듈이 추상화 된 모듈에 의존하게 해야 한다.

![image](https://user-images.githubusercontent.com/64974683/197345993-8c3302e9-1e3b-4f51-aa98-fb5142a694a0.png)
그림에서 볼 수 있듯이 추상적인 Copy가 구체적인 Read KeyBoard 등에 의존하게 설계하면 문제가 생긴다.
오른쪽과 같이 추상적인 Copy에 의존하게 만들어야 한다.

### 6-5. 설계 메트릭
설계를 마친 뒤, 설계의 결과가 원리들을 잘 적용하여 좋은 설계가 되었는가를 따져 봐야 한다.

#### 6-5-1. 전통적인 메트릭
설계 모델에 대한 전통적인 측정 방법
-크기 - 시스템 규모를 하나의 척도로 측정 / 모듈의 개수와 모듈 사이 인터페이스 개수를 세는 방법
-복잡도 - 얼마나 서로 연관되어 복잡한지를 나타냄 3가지의 식이 있다.
-결합도 - 모듈 사이에 실제적으로 어느 정도 연결되어 있는지를 나타내는 척도(입출력 매개변수, 전역변수 등)
-응집도 - 잘 정의된 단일 목적을 성취하기 위하여 오퍼레이션들이 얼마나 잘 협동하는 가를 나타낸 척도
-정보흐름 - 얼마나 많은 정보가 처리되어 흘러가는지를 나타내는 척도

-모듈의 구조적 복잡도 = (모듈의 팬 아웃 개수)^2
데이터 복잡도 = (입력 및 출력 변수의 개수) / (팬 아웃 + 1)
시스템 복잡도 = 구조적 복잡도 + 데이터 복잡도
 
#### 6-5-2. 객체지향 메트릭
![image](https://user-images.githubusercontent.com/64974683/197346040-f4a8ac3f-784c-4ca1-a523-223a9d1f5076.png)
