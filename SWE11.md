# 11.유지보수
포인트1. 유지보수 작업과 개발 작업의 차이는 무엇인가?

포인트2. 유지보수 작업 과정은 무엇인가?

포인트3. 형상관리 작업이란 무엇이며 그 절차와 방법은 무엇인가?

포인트4. 역공학과 리엔지니어링이란 무엇이며 어떻게 하는가?

포인트5. 유지보수 작업 방법과 지원 도구에는 어떤 것이 있는가?

유지보수 - 개발 후에 이루어지는 소프트웨어의 변경 작업
- 유지보수 단계는 소프트웨어가 가장 유용항게 활용되는 시간
- 소프트웨어 환경과 비즈니스 요구에 따라 진화

## 11-1 유지보수 소개
레거시 시스템
- 수십년 전 구축 후 지금까지 사용하고 있는 소프트웨어 시스템

레거시 시스템 대체하지 못하는 이유
- 대체하기 위해 비용이 많이 들기 떄문
- 전문가, 사용자들의 수 십년 동안의 경험, 지능이 녹아있음
- 새로운 시스템이 우수하다는 보장 x

### 11-1-1 변경의 이유와 유지보수 유형

시스템의 릴리즈, 배포, 설치 후에는 여러가지 이유로 변경 필요
-버그 제거
  - 운용 단계에서 버그가 발생하면 제거필요
  - 번경된 소프트웨어가 예전에 선택한 테스트에 대해 통과여부를 가리는 리그레션 테스트 필요
- 운영 환경 변화
  - 하드웨어, 플랫폼, 시스템 형상의 변화
- 정부 정책, 규레의 변화
- 비즈니스 절차의 변화
- 미래 문제를 배제하기 위해  

유지보수 유형
- 수정형: 발견된 결함을 고치기 위해 
- 적응형 : 변경된 환경에서도 계속 사용할 수 있도록 소프트웨어를 이식하거나 변경 
- 완전형
  - 소프트웨어 설치 후에 성능이나 유지보수성을 개선하기 위해
  - 코드의 기능 및 효율성 향상과 사용자의 요구 변화에 따라 시스템의 기능 변경
  - 사용자에 의한 기능 보강 요청에 의해 발생
- 예방형 : 오류 발생을 방지하기 위해 
![image](https://user-images.githubusercontent.com/64974683/206375700-431276dc-0fe0-4eec-9b85-6cee795234c6.png)

### 11-1-2 lehman의 법칙
1. 지속적인 변경의 원칙 (Law of continuing change)
- 시스템이 릴리스 된 후 변경은 그 시스템이 대체될 때 까지 변경됨
- 시스템의 요구는 항상 변화하기 때문에 소프트웨어가 사용되려면 계속 좋은 방향으로 진화되어야 함

2. 엔트로피, 복잡도 증가의 법칙 (Law of increasing entropy or complexity)
- 시스템의 구조는 변경되면서 더 나빠진다 -> 변경이 오류를 유발, 더 많은 변경을 요구하기 때문
- 시스템이 변경될 수록 그 구조는 더 복잡해지고, 구조를 단순화 하기 위해 많은 노력이 필요함
- 유지보수 비용을 줄이기 위하여 시스템 구조를 개선하는 재구조화 또는 리엔지니어링이 필요함

3. 자기 통제의 법칙 (Law of self-regulation)
- 시스템이 계속 피드백 되기에 가능
- 안정성 유지의 법칙, 친근성 유지의 법칙, 지속성 성장의 규칙을 일반화 한 것

4. 안정성 유지의 법칙 (Law of organizational stability)
- 진화하는 시스템의 유지보수 프로세스는 시스템이 소멸할 때 까지 일정한 평균 작업량을 보임

5. 친근성 유지의 법칙 (Law of familiarity)
- 시스템의 평균 성장률은 소멸될 때 까지 일정함
- 시스템 개발 전 단계에 걸쳐 각 버전의 변화는 거의 일정

6. 지속적 성장의 법칙 (Law of continuing growth)
- E 타입의 시스템은 사용자를 만족시키기 위하여 기능적 성장을 계속하여야 함

7. 품질 저하의 법칙 (Law of declining quality)
- E 타입 시스템의 품질은 운영 환경의 변화에 완전히 적응하지 못하는 한 저하됨

8. 피드백 시스템의 법칙 (Law of feedback systems)
- 진화 프로세스는 여러 단계의 여러번 반복, 중요한 역할을 담당하는 여러 관련자들의 피드백으로 구성됨

## 11-2 유지보수 작업 과정
소프트웨어 개발은 코딩의 중심 작업, 유지 보수는 이해 중심의 작업

### 11-2-1 유지보수 작업
유지보수 작업에 포함되는 기본적 작업들
1. 현재 프로그램의 이해
  - 엔지니어는 소프트웨어 변경 전에 소프트웨어를 알아야함
2. 변경 파악과 분석
  - 필요한 변경 파악, 영향도와 소요비용, 리스크 분석
3. 변경 연향 파악
  - 시스템 컨포넌트에 가해진 변경은 다른 컴포넌트에 영향을 줄 수 있음
  - 변경의 이해 당사자들에게 알리고 피드백을 얻어야함 
4. 변경 구현, 테스트, 설치
  - 구현으로부터 설계 복구, 변경된 요구를 만족시키기 위해 설계 변경 가능
  - 변경 반영을 위해 시스템 수정
  - 시스템을 올바로 고쳤는지 확인하기 위해 통합, 승인, 시스템 테스트 실시
![image](https://user-images.githubusercontent.com/64974683/206377332-237f982f-cf38-45ba-852d-f8e593fb954a.png)

### 11-2-2 유지보수 프로세스
유지보성을 형성하기 위한 요구가 어떤 것인지 인식하기 위해 모델 필요
- 즉시 수정 모델
  - 문제 발견 > 확인되면 가능한 빨리 문제 해결 방식
  - 장기적인 효과를 자세히 분석하지 않고, 바로 수정하며, 문서 수정은 최소화
  - 오늘날도 많이 사용
  - 장점:
    - 한두명의 유지보수 담당자가 시스템을 잘 알고 있고, 상세한 문서 없이 관리할 수 있으면 적절한 모델
    - 고객의 빠른 수정 요구 적용
  - 단점:
    - 한두명의 유지보수 담당자가 시스템을 잘 알고 있고, 상세한 문서 없이 관리할 수 있는 상황이 흔하지 않음
    - 잘못하면 매우 어렵고, 비용이 많이 드는 문제 초래
    - 변경효과를 간과할 수 있음 > 파급된 더 이상의 수정을 잘 못된 것으로 몰아갈 수 있음
    - 인력과 자원이 긴급 보수에 투입되어야함 > 문서 변경에 투자하는 시간 감소 > 오류 탐색 기회 탐소 
![image](https://user-images.githubusercontent.com/64974683/206377667-e30f251b-9582-4369-b903-dcf18c7f1d48.png)

