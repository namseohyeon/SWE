# 7. 아키텍처 설계와 패턴

포인트1. 소프트웨어 아키텍처란 무엇인가?

포인트2. 아키텍처는 어떻게 표현하는가?

포인트3. 아키텍처 유형에는 어떤 것들이 있는가?

포인트4. 디자인 패턴은 무엇이며 어떤 패턴이 있는가?

포인트5. 아키텍처 설계는 어떻게 평가하나?  

## 7-1 아키택처 기초
### 7-1-1 아키텍처란?
+ 소프트웨어 시스템에서 높은 추상 수준의 구성요소들의 관계, 연결 유형 및 상호 작용
+ 비기능적 품질 요구를 충족시키기 위해 좋은 아키텍처가 되어야함

### 7-1-2 아키텍처의 역할
+ 시스템의 구조를 확립하는 소프트웨어 개발에서 중심축을 담당
+ 모든 단계에 영향을 줄만한 초기 의사결정의 핵심
![image](https://user-images.githubusercontent.com/64974683/205529740-ea363c70-7ae3-40ee-a472-3f75a98f975c.png)


### 7-1-3 아키텍처의 표현
+ 개발팀과 관계자들이 이해라기 쉽도록 추상화
+ 아키텍처에서 컴포넌트를 블랙박스로 명시& 외부에 보일 수 있는 구조적 속성만 나타냄
#### 계층적 분할
- 아키텍처를 표현하는 가장 강력한 방법
- 상세수준에 따라 나눠 표현된 컴포넌트를 더 자세히 나타내기 위해 분할하는 방법
- 분할되지 않은 컴포넌트(클라이언트)는 내부 구조와 동작이 전체 시스템의 비기능적 품질 목표 달성에 중요하지x

![image](https://user-images.githubusercontent.com/64974683/205530074-0f99648a-8a39-4396-b17e-3a0b2b689655.png)

#### 패키지 다이어그램
##### 패키지
- 클래스를 의미있는 관련된 그룹으로 구성하는 메커니즘
- 클래스를 논리적으로 그루핑하는 것

##### 패키지 다이어그램
- 소프트웨어 구조를 파악하는데 적합
- 패키지 = 클래스의 그룹이기 때문에 높은 수준의 추상화된 서브시스템 표현가능
- 패키지 속에 패키지 중첩 될 수 o

###### 서브시스템으로 분할하는 방법
- 같은 유스케이스에서 발견된 객체는 같은 서브시스템으로 구분
- 서브시스템 사이에 데이터를 전달하기 위해 사용되는 객체는 단복 서브 시스템으로 만듬
- 서브시스템 경계에 있는 연관 관계를 최소화
- 같은 서브시스템 안에 있는 모든 객체는 기능적으로 연관이 있어야함

=> 서브 시스템으로 분할하면 객체사이의 의존은 최소화 가능 > 도메인의 복잡성을 줄일 수 있음

## 7-2 아키텍처 스타일
: 개발할 시스템의 타입은 모든 개발 작업에 영향

#### 시스템 타입
1. 대화형 시스템
  - pc와 웹 어플리케이션이 보급되면서 보편적 시스템이 되었음
  - 시스템 속 객체들이 이를 위하여 어떻게 협력하고 상호작용하는지 상세 모델링
2. 이벤트 중심 시스템
  - 상태의존적 & 반응동작을 보임
  - 주로 임베디즈 시스템
  - 같은 이벤트라도 시스템이 다른 상태에 있다면 반응이 다름
  - 상태 다이어그램으로 모델링하며, 상태 단위로 아키텍쳐가 구성됨
3.변환 시스템
  - 과학 계산, 엔지니어링 계산 분야에서 많이 볼 수 있음
  - 작업에 대한 정보를 받아 작업흐름을 결정하고, 여기에 대한 정보로 변경
  - 변환 과정이 아키턱처의 중요한 구성요소가됨
4. 객체 영속 시스템
  - 저장 미디어를 속이고, 데베나 파일 시스템에 객체를 저장할 수 있거, 검색할 수 있는 능력을 가진 시스템
  - 데베를 사용하여 분산 시스템이라고도 불림
  - 데이터 베이스 구현에 대한 변경을 숨김

### 7-2-1 클라이언트 서버형
- 서버: 강력한 서능으로 자원을 관리하며 클라이언트가 요청하는 기능이나 자원 제공
- 클라이언트: 서버에 있는 자원을 사용을 위해 서버에 접속

- 장점
  + 데이터 집중화 : 모든 데이터는 서버에 모아 데이터 구성과 관리를 단순화 함
  + 보안 : 클라이언트의 요청을 모니터링하고, 기록할 수 있음, 인증 완료된 클라이언트만 서비스 접근 가능
 - 단점
  + 병목: 서버와 통신하려는 클라이언트가 증가하면, 서버의 부하가 올라가 네트워크 속도가 느려짐
  + 비용: 설치 및 관리 비용이 일반적으로 높음
  + 비강인성 : 서버가 고장나면 클라이언트는 더이상 작동 할 수 없음

### 7-2-2 계층형
- 소프트웨어 기능을 수직으로 상호작용하는 여러층으로 분할하는 형태
- 각 층 사이의 메세지를 교환

![image](https://user-images.githubusercontent.com/64974683/205532502-c841ea39-cd9f-46cd-b326-d215fa7943a6.png)

- 장점:
  - 추상화: 시스템에 대해 좋은 추상적인 뷰룰 제공 > 각 층의 역할, 책임, 관계를 잘 이해가능
  - 캡슣화, 응집, 결합: 자세한 데이터나, 메소드, 자원, 구현등이 각 층안에 캡슐화되어 층 사이에 가정하거나 이해해야할 사항 적음 > 각 층의 응집이 놀고, 층사이의 결합이 적다.
  - 재사용성: 각 층의 의존도가 적어 쉽게 다른 모듈로 교환할 수 있고, 다른 시스템에 사용 가능
- 단점:
  - 이웃층과의 커뮤니케이션이 제한적이며, 결합력이 맞아서 시스템을 계층으로 구성하기 쉬지 않음

### 7-2-3 이벤트 기반 아키텍처
- 구성: 이벤트 생성자(이벤트 스트림 생성)와 이벤트 소비자(이벤트 수신 대기)로 구성
- 이벤트 > 실시간으로 처리 전달 > 즉시 소비자 응답
- 상태기반 처리가 대부분 > 이벤트와 현재 상태에 따라 다른 처리

![image](https://user-images.githubusercontent.com/64974683/205533470-1755f0c7-018a-4e09-a922-f0aafd7e1e96.png)

- 장점:
  - 캡슣화, 응집 : 이벤트의 생산자와 소비자가 분리되어 캡슣화
  - 확장성 : 시스템에 새 소비자를 쉽게 추가할 수 있음
  - 이벤트 도착 시 소비자가 즉시 이벤트에 응답 가능
  - 하위 시스템에서 이벤트 스트림을 독립적으로 확인 가능
- 단점:
  - 복잡성: 상태에 따라 복잡하고, 정교한 제어 필요
  - 테스팅: 각 상태에 허용된 이벤트가 제한적인 것을 정확히 테스트해야함, 허용되지 않은 이벤트에 대한 제어 필요

### 7-2-4 mvc(model - view - controller )
- 사용자 인터페이스로부터 비즈니스 로직과 데이터 분리 > 애플리케이션의 시각적 요소나 그 이면에서 실행되는 비즈니스 로직을 서로 영향 없이 쉽게 고칠 수 있는 아키텍처

##### 구성요소
- 컨트롤러
  - 모델에 명령을 보냄으로써 모델의 상태 변경
  - 관련된 뷰에 명령을 보내 모델의 표시 방법을 바꿀 수 있음
 - 모델
  - 데이터의 상태에 변호가 있을 때 컨트롤러와 뷰에 이를 통보
  - 모델의 변화에 따른 적용가능한 명령 (추가, 제거, 수정) 내릴 수 있음
- 뷰
  - 모델에서 통보를 하게 되면 최신 결과를 보여줌
  - 결과물 생성을 위해 모델로부터 정보를 얻어옴

![image](https://user-images.githubusercontent.com/64974683/205534193-e37ecaa4-f1a8-4757-8161-f53ed8bec3f9.png)

- 장점
  - 느슨한결합, 확장성 : 각 컴포넌트의 결합이 약해 다른 부분에 영향 주지 않고, 수정 가능
  - 다수의 다른 뷰 : 하나의 모델을 위하여 다수의 다른뷰를 쉽게 제공할 수 있음
  - 비동기 : 비동시 기술을 이용하여 애플리케이션을 빠르게 로딩할 수 있고, 개발자도 각 컴포넌트를 독립적으로 빠르게 개발가능
- 단점
  - 복잡도: 컴포넌트의 분리오 인하여 메커니즘 이해를 위한 복잡도 올라갈 수 있음
  - 비효율성 : 뷰에서 데이터를 접근하여야하는 비효율적인 부분있음
  - 각 컴포넌트 구현을 위한 여러가지 기술에 대한 이해가 필요함

### 7-2-5 파이프 필터
- 필터 사이에 데이터를 이동시키며 단계적으로 처리하는 구조
- 데이터의 흐름, 필터 구성요소로 구성
예시 > 컴파일러
![image](https://user-images.githubusercontent.com/64974683/205534605-8afe0166-481c-4024-9574-3ff45b3751c6.png)

=> 파이프 필터를 통하여 단방향으로 흐름

- 장점: 
  - 단순성 : 시스템을 일련의 입력, 출력, 변환으로 쉽게 볼 수 있음
  - 재사용: 다른 응용프로그램에서 필터를 쉽게 재사용, 교체 가능
  - 병렬성 : 병렬처리로 구현하기 쉬운 아키텍처 제공
- 단점
  - 자원의 낭비: 시간과 공간 낭비할 수 있음
  - 오류 조건을 쉽게 처리할 수 있는 방법이 없음 > 오류는 별도 출력 스트림으로 처리해야함

### 7-2-6 데이터 중심 아키텍처
- 공유된 자료가 중요한 시스템에서 채택
- 공유 데이터 저장소, 공유 데이터 접근자(공유데이터 추가, 삭제, 수정 가능)로 구성
- 접근자 간의 통신은 데이터에 대한 업데이트를 통하여 간접적으로 수행

![image](https://user-images.githubusercontent.com/64974683/205535069-c1198c3b-0d7c-49e4-91d2-84263da17394.png)

###### 데이터 중심 아키텍처의 유형
- 블랙 보드
  - 공유 데이터에 제어 스레드 포함
  - 공유 데이터 저장소는 옵서버 디자인 패턴을 사용하여 공유 데이터 변경 시 클라이언트에게 알림
- 리파지토리
  - 클라이언트는 공유 데이터를 질의하여 변경사항 발견
- 장점:
  - 낮은 결합: 접근자간의 통신은 공유 데이터 저장소를 통해 이뤄짐 > 다른 접근자에 영향x
  - 확장성: 각 접근자의 수정, 확정이 용이함
- 단점:
  - 단일 장애지점: 공유 데이터의 장애로 전체가 장애를 일으킬 수 있는 단일 장애 지점이 있음

### 7-2-7. Peer-to-Peer 스타일
- 각 컴포넌트는 동등하여 서비스를 요청하는 클라이언트가 될 수도 있고, 서비스를 제공하는 서버 역할을 할 수도 있음
- 시스템은 동일한 수신, 전송 데이터 양을 가지므로 대칭적인 시스템

Peer-to-Peer 스타일
![image](https://user-images.githubusercontent.com/64974683/205535544-887f045c-09f4-425c-bf50-50c60092e42e.png)

블록체인 기술이 Peer-to-Peer 아키텍처를 기반으로 하고 있음
>> 보안을 해결하기 위해 각 노드가 상대 노드들을 감시하고 일관성을 유지함

- 장점
  - 전담하는 애플리케이션이나 서버 없음
  - 규모 확장성이나 신뢰성이 개선됨
  - 컴포넌트에 고장이 있어도 전체 시스템은 가종 됨(단일 장애 지점x)
 - 단점
  - 보안에 취약할 수 있음
  - 중앙에서 제어할 수 있음
  - 공유된 자원으로 성능이 떨어질 수 있음

### 아키텍처 스타일의 비교
<table>
  <tr><td>스타일</td><td>장점</td><td>단점</td></tr>
  <tr><td>클라이언트 서버</td><td>- 클라이언트가 요청하는 서비스를 종합적으로 모델링하기 좋음</td><td>- 서비스요청이 서버에서 별도의 스레드로 처리
                                                                                                - 프로세스사이의 커뮤니케이션이 오버헤드 될 수 있음(클라언트들이 다른 표현 요구하기 떄문)</td></tr>
  <tr><td>계층형</td><td>- 하위층이 여러 상위층에 의하여 사용됨
- 각 층을 정확히 정의하면 각 층이 표준화 될 수 있음
- 다른 층에 영향을 주지 않고 수정을 층 안에 국한시킬 수 있음</td><td>- 광범위하게 적용하기 어려움 (이웃 층과의 커뮤니케이션이 제한적)
- 특정한 층이 상황에 따라 통과될 수도 있음</td></tr>
  <tr><td>이벤트 기반</td><td>- 이벤트 생산자, 소비자 연결을 쉽게 하고 추가할 수 있음
- 분산 응용에 효과적으로 적용 가능</td><td>- 상태에 따른 복잡하고 정교한 제어가 필요함
- 큰 규모에 적용하기 어려움</td></tr>
  <tr><td>mvc</td><td>- 동일 모델에 여러 가지 뷰를 런타임에 쉽게 연결하고 끊을 수 있음</td><td>- 복잡도가 증가하고 이로 인하여 사용자 액션을 위하여 불필요한 수정이 증가될 수 있음</td></tr>
  <tr><td>파이프 필터</td><td>- 병렬처리를 가능하게 함
- 쉽게 필터를 추가할 수 있고, 시스템이 확장될 수 있음</td><td>- 느린 필터에 의하여 시스템의 성능이 제한적이다
- 필터를 이동하면서 자료의 변환 오버헤드가 발생할 수 있음</td></tr>
  <tr><td>데이터 중심</td><td>- 새로운 응용을 쉽게 추가
- 데이터 공간의 확장이 용이함</td><td>- 모든 부분이 영향을 받아 중심 데이터의 구조를 변경하는 것이 쉽지 않다</td></tr>
  <tr><td>Peer-to-Peer</td><td>	- 중앙집중을 피할 수 있음
- 노드 하나의 고장으로 시스템이 멈추지 않음
- 자원과 컴퓨팅 파워의 확장성이 뛰어남</td><td>- 서비스의 품질을 보장하기 어려움
- 보안을 보장하기 어려움
- 성능이 노드의 수에 좌우됨</td></tr>
</table>


## 7-3 디자인 패턴
- 아키텍처 설계 수준보다 낮은 수준의 설계 문제에 재사용 가능한 솔루션 제공
  ![image](https://user-images.githubusercontent.com/64974683/205537880-bd3e08ea-5d58-42c9-9da2-c3f8b9462f52.png)

- 디자인 패턴을 이용하여 찾을 수 있는 두가지 솔루션
  - 옵서버 패턴에 따라 모델이 뷰의 상태 변경을 알리도록
  - 모델에 대한 변경이 컨트롤러에 의해 시작되다면 모델에 상태변경이 있을 때 컨트롤러가 뷰에 알리도록

### 7-3-1 디자인 패턴의 혜택(디자인 패턴을 사용하는 이유)
1. 쉽게 재사용 가능
2. 설계 작업이 쉬워짐(높은 품질의 솔루션이 이미 제공, 특정상황에 대하여 패턴을 특수화하는 방법을 알아야함)
3. 설계 관련 지식이 정리됨(디자인 패턴에 대한 학습은 개발자에게 제대로 된 걸계를 할 수 잇게 함)
4. 디자인을 논의하기 위한 의사소통이 쉬워짐(디자인 패턴은 설계에 대한 아이디어를 논의하기 위해 추상화 레벨에서 공통 어휘를 정의하고, 정확하게 설명하는 기틀 제공)
5. 객체 지향 설계 원리를 잘 따르게 됨

### 7-3-2 디자인 패턴의 형식
- 패턴이름(짧은 이름, 설명 > 의사소통 촉진)
- 소개(배경 정의, 패턴 학습)
- 해결하는 문제(설계 이슈에 대해 설명)
- 솔루션(디자인 패턴의 본질, 실행코드보다 추상적인 설계조각, 클래스 다이어 그램이 포함되며, 클래스 간 헙업이 중요할 때는 상호작업 다이어그램이 포함)
- 예제(추상적인 해법 > 적용하는 법 습득 쉽지 x, 특정 예제에 저굥된 것을 해법이해+ 구현 사례 제공)
- 관련 패턴(패턴은 서로 관련된 것이 있음, 한 태천이 다른 패턴 포함할 수 o, 패턴 그웁이 비슷한 문제 해결할 수 o)

### 7-3-3 싱글톤 패턴
- 객체를 강제적으로 하나 생성
=> 클라이언트들이 개별적으로 각각 객체 생성x, 하나를 가지고 공공으로 사용할 수 있음

- 솔루션
  - 클래스 안에 자신을 정적 속성으로 갖게 함 -> 객체는 유일하게 됨
  - 생성된 유일한 객체를 반환하는 정적 메서드를 사용하여 접근하게 함
  - 처음 호출될 때 -> 클래스의 인스턴스가 생성, 리턴
  - 후속 호출 -> 만들어진 인스턴스가 리턴됨
  - 클래스의 생성자 - private로 선언 --> 객체를 접근하는 정적 메서드가 클래스의 인스턴스 제작, 유일하게 접근 
![image](https://user-images.githubusercontent.com/64974683/205549436-70d5e72f-3ab5-41fd-acab-dd3a2e32ea94.png)

### 7-3-4 반복자 패턴
- 객체 그룹과 관련된 집합 클래스와 함께 아용됨
- 집합 클래스의 자료구조와 상관 없이 집합에 소속된 요소들을 쉽게 접근하기 위하여 반복자를 두어 접근하고, 검색
- 
- 해결하려는 문제
  - 집합 내부 요소의 저장 방법과 반복적 접근 알고리즘 구현에 관계없이 집합 요소에 순차적으로 액세스하는 방법을 제공한다
  - 집계와 방법을 구현하는 방법은 클라이언트에 영향을 주지 않고 변경될 수 있음
  
-  솔루션 (반복자 패턴을 구현하는 방법)
1. 반복 수행하는 집합 클래스에 대하여 접근하는 반복자를 Iterator 인터페이스로 정의함
2. 집합에 의해 구현될 Aggregate 인터페이스를 정의함 -> 인터페이스에는 반복자를 반환하는 팩토리 메소드가 포함
3. 추상 팩토리 메소드를 상속 구현하여 특정 집합의 반복자를 반환하는 집합 클래스를 작성함
4. 정의한 Iterator, Aggregate 인터페이스를 이용하는 클라이언트 코드를 작성함
![image](https://user-images.githubusercontent.com/64974683/205549622-a41662ed-c2c8-4db9-a463-66da5b03b6a8.png)

### 7-3-5
사용 가능한 서비스의 인터페이스를 클라이언트가 예상하는 인터페이스에 맞게 조정(호환되도록 변환)할 수 있음

- 해결하는 문제: 
클라이언트와 서비스가 호환되지 않는 인터페이스를 가지고 있지만 함께 작동하고 싶을 때 사용
어탭터로 인하여 클라이언트와 서비스는 컴포넌트를 수정하지 않아도 함께 작동 가능

- 솔루션: 
사용하고 싶은 서비스에 연관, 클라이언트가 기대하는 인터페이스를 구현한 어댑터 클래스 작성
어댑터 클래스는 클라이언트가 기대하는 인터페이스를 구현 -> 클라이언트 - 어댑터 클래스 상호작용 가능
![image](https://user-images.githubusercontent.com/64974683/205549753-03988ae9-b2eb-4acb-9cc4-67291abbdeb6.png)

7-3-6. 데코레이터 패턴
집합 관계와 위임을 사용하여 기존 클래스의 동작을 가볍고 유연하게 확장

- 수정에 의한 추가: 수정에 의한 추가는 OCP원리(확장을 위해서는 open, 수정을 위해서는 close)에 위배
- 상속에 의한 추가: 
  - 서브클래스를 통하여 동작 추가 - OCP원칙을 따름 -> 기본 클래스에 코드변경 없이 새로운 서브클래스 추가 가능
  - 기본 클래스 안에 보호된 인터페이스가 서브클래스에 노출 -> 캡슐화를 약화 -> 정보은닉에 취약
  - 기능의 조합 수 만큼의 서브클래스가 필요함
- 해결하는 문제: 
  - 기본클래스의 동작을 동적으로 추가하는 문제를 해결
  - 객체에 장식적인 책임을 추가할 수 있도록 유연하기 위해 상속 대신 구성 관계 사용
- 구성요소
  - componernt 클래스
  - 확장이 담긴 데코레이터

### 7-3-7 팩토리 메소드 패턴
- 클라이언트에서 사용할 클래스의 객체를 생성하는 책임을 분리하여 객체 생성에 변화 대비하려는 문제 해결
- 솔루션
  - 객체를 생성하기 위한 팩토리 메소드를 포함하는 추상 클래스 정의
  - 클라이언트는 이 인터페이스를 사용하여 객체 생성 

### 7-3-8추상 팩토리 패턴 
객체를 사용할 클라이언트에서 구체적인 객체 생성을 지정하는 책임을 분리하기 위하여 추상 인터페이스를 이용하여 관련 객체 패밀리를 생성

- 솔루션
  - 사용하려는 모든 Product에 대하여 추상 인터페이스를 정의
  - 관련 Product 그룹을 만들기 위한 추상 팩토리 클래스를 정의
  - 각 관련 Product 그룹에 대해 추상 팩토리 인터페이스를 구현한 ConcreateFactory 클래스를 작성하고 함께 사용되는 Product 패밀리를 작성
  - 클라이언트는 Product의 추상 인터페이스 및 추상 팩토리 인터페이스에 밀접하게 연결되며 특정 Product 및 특정 Product 팩토리에 느슨하게 연결

### 7-3-9 상태 패턴
- 메소드의 교환에 초점을 둔 행위 패턴 중 하나
- 상태에 따라 객체의 동작을 변경해야하는 경우
- 맥락과 상태를 별도로 구현하여 융통성을 달성하기 위한 체계적이고 느슨한 결합방식

### 7-3-10 옵서버 패턴
데이터를 보관하고 있는 subject가 그 데이터를 이용하여 옵서버와 효과적으로 통신하면서 느슨하게 결합
- 솔루션
> Subject 클래스
- 자신의 데이터에 관심이 있는 옵서버 목록을 유지
- 상태가 변경될 때 옵서버에게 알리는 동작을 갖도록 함
- Subject가 변경 사항을 알리면 내용을 받아갈 수 있는 콜백 메소드를 정의함
- Subject는 상태를 가진 특정Subject로 상속될 수 있음

> Observer 클래스 : 변경을 통지 받고 접근을 요청한다

## 표로 정리
<img width="584" alt="image" src="https://user-images.githubusercontent.com/64974683/205550932-606463e9-31bd-4255-9f70-8bb975e4ef5a.png">

## 7-4 아키텍처 평가
아키텍처나 디자인 패턴의 속성, 강점 및 약점을 결정하는 방법
> 강점, 약점이 무엇이냐를 따지는 척도

선택한 아키텍처가 기능적 비기능적 품질 요구사항을 모두 충족시킬 수 있음을 보장

방법 
  - samm: 시나리오 기반 평가 방법
    - 시나리오를 사용하여 소프트웨어, 아키텍처를 조사할 수 있는 체계적인 수단 제공
    - 아키텍처가 시나리오를 실행할 수 있는지 여부 결정
    - 실행하지 못하는 경우 시나리오를 지원하도록 변경하는데 필요한 사항들을 나열하고 변경 비용 추정
    - 요구사항에 따라 시나리오를 도출하기 위해 관련 이해 관계자가 참여해야함

    - 시나리오 사례

    > 직접 시나리오
    시스템의 변경이 요구되지 않는 시나리오
    일반적인 유스케이스에 대한 아키텍처 지원의 평가, 인터페이스에 의하여 지원되는 보통 기능들에 대하여 아키텍처 평가
    장기간 사용에 의한 자료의 함몰이 있는지, 통신 채널을 통하여 자료를 보낼 때 무결성을 보이는지에 대하여 아키텍처 평가

    > 간접 시나리오
    시스템의 변경이 요구되는 시나리오
    새로운 기능을 추가하거나 원하지 않는 기능을 삭제할 때 아키텍처가 지원하는지 평가한다
    새로운 하드웨어, 운영체제, IO 장치 환경에 적응하는지 평가함
    모듈화, 최적화, 재사용 가능하도록 재구조화 할 때 아키텍처가 수용할 수 있는지 평가

  - ATAM: 여러가지 품질 속성에 초점을 맞춰 평가
    - 아키텍처의 절충한, 설계 타협점을 찾아내고, 아케텍처 내부에 있는 리스크 발견
    - ![image](https://user-images.githubusercontent.com/64974683/205551446-aee2d6f1-2e99-43c9-aee9-10a7dccff639.png)
    - 아키텍처의 품질 목표와 민감한 부분을 찾아냄
    - 중요한 작업은 품질 특성 목표를 파악하고 이에 대한 우선순위와 시나리오 작성 
    
    >> 유틸리티 트리
    <table>
      <tr><td>품질특성</td><td>시나리오 사례</td></tr>
      <tr><td>유지보수성</td><td>	- 연동하는 시스템의 상태 확인 기능 추가
- 모바일 단말기 접속 기능 추가
- 수강 신청 프로세스의 변경
- 커리큘럼 변경 및 추가</td></tr>
      <tr><td>성능</td><td>- 수강 과목 검색 기능 속도의 향상
- 수강 신청 기능의 처리량 향상</td></tr>
      <tr><td>가용성</td><td>- 수강 과목 검색 기능 속도의 향상
- 수강 신청 기능의 처리량 향상</td></tr>
      <tr><td>보안성</td><td>	- 사용자 ID별 DB 접근 제어
- 다른 시스템에서 접근할 때 제어하는 기능</td></tr>
      <tr><td>사용용이성</td><td>	- 신규 사용자의 시스템 적응 단축
- 수강 신청 오류 처리 기능에서 도움말 기능 보완</td></tr>
    </table>



    - 
