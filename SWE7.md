# 7. 아키텍처 설계와 패턴

포인트1. 소프트웨어 아키텍처란 무엇인가?

포인트2. 아키텍처는 어떻게 표현하는가?

포인트3. 아키텍처 유형에는 어떤 것들이 있는가?

포인트4. 디자인 패턴은 무엇이며 어떤 패턴이 있는가?

포인트5. 아키텍처 설계는 어떻게 평가하나?  

## 7-1 아키택처 기초
### 7-1-1 아키텍처란?
+ 소프트웨어 시스템에서 높은 추상 수준의 구성요소들의 관계, 연결 유형 및 상호 작용
+ 비기능적 품질 요구를 충족시키기 위해 좋은 아키텍처가 되어야함

### 7-1-2 아키텍처의 역할
+ 시스템의 구조를 확립하는 소프트웨어 개발에서 중심축을 담당
+ 모든 단계에 영향을 줄만한 초기 의사결정의 핵심
![image](https://user-images.githubusercontent.com/64974683/205529740-ea363c70-7ae3-40ee-a472-3f75a98f975c.png)


### 7-1-3 아키텍처의 표현
+ 개발팀과 관계자들이 이해라기 쉽도록 추상화
+ 아키텍처에서 컴포넌트를 블랙박스로 명시& 외부에 보일 수 있는 구조적 속성만 나타냄
#### 계층적 분할
- 아키텍처를 표현하는 가장 강력한 방법
- 상세수준에 따라 나눠 표현된 컴포넌트를 더 자세히 나타내기 위해 분할하는 방법
- 분할되지 않은 컴포넌트(클라이언트)는 내부 구조와 동작이 전체 시스템의 비기능적 품질 목표 달성에 중요하지x

![image](https://user-images.githubusercontent.com/64974683/205530074-0f99648a-8a39-4396-b17e-3a0b2b689655.png)

#### 패키지 다이어그램
##### 패키지
- 클래스를 의미있는 관련된 그룹으로 구성하는 메커니즘
- 클래스를 논리적으로 그루핑하는 것

##### 패키지 다이어그램
- 소프트웨어 구조를 파악하는데 적합
- 패키지 = 클래스의 그룹이기 때문에 높은 수준의 추상화된 서브시스템 표현가능
- 패키지 속에 패키지 중첩 될 수 o

###### 서브시스템으로 분할하는 방법
- 같은 유스케이스에서 발견된 객체는 같은 서브시스템으로 구분
- 서브시스템 사이에 데이터를 전달하기 위해 사용되는 객체는 단복 서브 시스템으로 만듬
- 서브시스템 경계에 있는 연관 관계를 최소화
- 같은 서브시스템 안에 있는 모든 객체는 기능적으로 연관이 있어야함

=> 서브 시스템으로 분할하면 객체사이의 의존은 최소화 가능 > 도메인의 복잡성을 줄일 수 있음

## 7-2 아키텍처 스타일
: 개발할 시스템의 타입은 모든 개발 작업에 영향

#### 시스템 타입
1. 대화형 시스템
  - pc와 웹 어플리케이션이 보급되면서 보편적 시스템이 되었음
  - 시스템 속 객체들이 이를 위하여 어떻게 협력하고 상호작용하는지 상세 모델링
2. 이벤트 중심 시스템
  - 상태의존적 & 반응동작을 보임
  - 주로 임베디즈 시스템
  - 같은 이벤트라도 시스템이 다른 상태에 있다면 반응이 다름
  - 상태 다이어그램으로 모델링하며, 상태 단위로 아키텍쳐가 구성됨
3.변환 시스템
  - 과학 계산, 엔지니어링 계산 분야에서 많이 볼 수 있음
  - 작업에 대한 정보를 받아 작업흐름을 결정하고, 여기에 대한 정보로 변경
  - 변환 과정이 아키턱처의 중요한 구성요소가됨
4. 객체 영속 시스템
  - 저장 미디어를 속이고, 데베나 파일 시스템에 객체를 저장할 수 있거, 검색할 수 있는 능력을 가진 시스템
  - 데베를 사용하여 분산 시스템이라고도 불림
  - 데이터 베이스 구현에 대한 변경을 숨김

### 7-2-1 클라이언트 서버형
- 서버: 강력한 서능으로 자원을 관리하며 클라이언트가 요청하는 기능이나 자원 제공
- 클라이언트: 서버에 있는 자원을 사용을 위해 서버에 접속

- 장점
  + 데이터 집중화 : 모든 데이터는 서버에 모아 데이터 구성과 관리를 단순화 함
  + 보안 : 클라이언트의 요청을 모니터링하고, 기록할 수 있음, 인증 완료된 클라이언트만 서비스 접근 가능
 - 단점
  + 병목: 서버와 통신하려는 클라이언트가 증가하면, 서버의 부하가 올라가 네트워크 속도가 느려짐
  + 비용: 설치 및 관리 비용이 일반적으로 높음
  + 비강인성 : 서버가 고장나면 클라이언트는 더이상 작동 할 수 없음

### 7-2-2 계층형
- 소프트웨어 기능을 수직으로 상호작용하는 여러층으로 분할하는 형태
- 각 층 사이의 메세지를 교환

![image](https://user-images.githubusercontent.com/64974683/205532502-c841ea39-cd9f-46cd-b326-d215fa7943a6.png)

- 장점:
  - 추상화: 시스템에 대해 좋은 추상적인 뷰룰 제공 > 각 층의 역할, 책임, 관계를 잘 이해가능
  - 캡슣화, 응집, 결합: 자세한 데이터나, 메소드, 자원, 구현등이 각 층안에 캡슐화되어 층 사이에 가정하거나 이해해야할 사항 적음 > 각 층의 응집이 놀고, 층사이의 결합이 적다.
  - 재사용성: 각 층의 의존도가 적어 쉽게 다른 모듈로 교환할 수 있고, 다른 시스템에 사용 가능
- 단점:
  - 이웃층과의 커뮤니케이션이 제한적이며, 결합력이 맞아서 시스템을 계층으로 구성하기 쉬지 않음

### 7-2-3 이벤트 기반 아키텍처
- 구성: 이벤트 생성자(이벤트 스트림 생성)와 이벤트 소비자(이벤트 수신 대기)로 구성
- 이벤트 > 실시간으로 처리 전달 > 즉시 소비자 응답
- 상태기반 처리가 대부분 > 이벤트와 현재 상태에 따라 다른 처리

![image](https://user-images.githubusercontent.com/64974683/205533470-1755f0c7-018a-4e09-a922-f0aafd7e1e96.png)

- 장점:
  - 캡슣화, 응집 : 이벤트의 생산자와 소비자가 분리되어 캡슣화
  - 확장성 : 시스템에 새 소비자를 쉽게 추가할 수 있음
  - 이벤트 도착 시 소비자가 즉시 이벤트에 응답 가능
  - 하위 시스템에서 이벤트 스트림을 독립적으로 확인 가능
- 단점:
  - 복잡성: 상태에 따라 복잡하고, 정교한 제어 필요
  - 테스팅: 각 상태에 허용된 이벤트가 제한적인 것을 정확히 테스트해야함, 허용되지 않은 이벤트에 대한 제어 필요

### 7-2-4 mvc(model - view - controller )
- 사용자 인터페이스로부터 비즈니스 로직과 데이터 분리 > 애플리케이션의 시각적 요소나 그 이면에서 실행되는 비즈니스 로직을 서로 영향 없이 쉽게 고칠 수 있는 아키텍처

##### 구성요소
- 컨트롤러
  - 모델에 명령을 보냄으로써 모델의 상태 변경
  - 관련된 뷰에 명령을 보내 모델의 표시 방법을 바꿀 수 있음
 - 모델
  - 데이터의 상태에 변호가 있을 때 컨트롤러와 뷰에 이를 통보
  - 모델의 변화에 따른 적용가능한 명령 (추가, 제거, 수정) 내릴 수 있음
- 뷰
  - 모델에서 통보를 하게 되면 최신 결과를 보여줌
  - 결과물 생성을 위해 모델로부터 정보를 얻어옴

![image](https://user-images.githubusercontent.com/64974683/205534193-e37ecaa4-f1a8-4757-8161-f53ed8bec3f9.png)

- 장점
  - 느슨한결합, 확장성 : 각 컴포넌트의 결합이 약해 다른 부분에 영향 주지 않고, 수정 가능
  - 다수의 다른 뷰 : 하나의 모델을 위하여 다수의 다른뷰를 쉽게 제공할 수 있음
  - 비동기 : 비동시 기술을 이용하여 애플리케이션을 빠르게 로딩할 수 있고, 개발자도 각 컴포넌트를 독립적으로 빠르게 개발가능
- 단점
  - 복잡도: 컴포넌트의 분리오 인하여 메커니즘 이해를 위한 복잡도 올라갈 수 있음
  - 비효율성 : 뷰에서 데이터를 접근하여야하는 비효율적인 부분있음
  - 각 컴포넌트 구현을 위한 여러가지 기술에 대한 이해가 필요함

### 7-2-5 파이프 필터
- 필터 사이에 데이터를 이동시키며 단계적으로 처리하는 구조
- 데이터의 흐름, 필터 구성요소로 구성
예시 > 컴파일러
![image](https://user-images.githubusercontent.com/64974683/205534605-8afe0166-481c-4024-9574-3ff45b3751c6.png)

=> 파이프 필터를 통하여 단방향으로 흐름

- 장점: 
  - 단순성 : 시스템을 일련의 입력, 출력, 변환으로 쉽게 볼 수 있음
  - 재사용: 다른 응용프로그램에서 필터를 쉽게 재사용, 교체 가능
  - 병렬성 : 병렬처리로 구현하기 쉬운 아키텍처 제공
- 단점
  - 자원의 낭비: 시간과 공간 낭비할 수 있음
  - 오류 조건을 쉽게 처리할 수 있는 방법이 없음 > 오류는 별도 출력 스트림으로 처리해야함

### 7-2-6 데이터 중심 아키텍처
- 공유된 자료가 중요한 시스템에서 채택
- 공유 데이터 저장소, 공유 데이터 접근자(공유데이터 추가, 삭제, 수정 가능)로 구성
- 접근자 간의 통신은 데이터에 대한 업데이트를 통하여 간접적으로 수행

![image](https://user-images.githubusercontent.com/64974683/205535069-c1198c3b-0d7c-49e4-91d2-84263da17394.png)

###### 데이터 중심 아키텍처의 유형
- 블랙 보드
  - 공유 데이터에 제어 스레드 포함
  - 공유 데이터 저장소는 옵서버 디자인 패턴을 사용하여 공유 데이터 변경 시 클라이언트에게 알림
- 리파지토리
  - 클라이언트는 공유 데이터를 질의하여 변경사항 발견
- 장점:
  - 낮은 결합: 접근자간의 통신은 공유 데이터 저장소를 통해 이뤄짐 > 다른 접근자에 영향x
  - 확장성: 각 접근자의 수정, 확정이 용이함
- 단점:
  - 단일 장애지점: 공유 데이터의 장애로 전체가 장애를 일으킬 수 있는 단일 장애 지점이 있음

### 7-2-7. Peer-to-Peer 스타일
- 각 컴포넌트는 동등하여 서비스를 요청하는 클라이언트가 될 수도 있고, 서비스를 제공하는 서버 역할을 할 수도 있음
- 시스템은 동일한 수신, 전송 데이터 양을 가지므로 대칭적인 시스템

Peer-to-Peer 스타일
![image](https://user-images.githubusercontent.com/64974683/205535544-887f045c-09f4-425c-bf50-50c60092e42e.png)

블록체인 기술이 Peer-to-Peer 아키텍처를 기반으로 하고 있음
>> 보안을 해결하기 위해 각 노드가 상대 노드들을 감시하고 일관성을 유지함

- 장점
  - 전담하는 애플리케이션이나 서버 없음
  - 규모 확장성이나 신뢰성이 개선됨
  - 컴포넌트에 고장이 있어도 전체 시스템은 가종 됨(단일 장애 지점x)
 - 단점
  - 보안에 취약할 수 있음
  - 중앙에서 제어할 수 있음
  - 공유된 자원으로 성능이 떨어질 수 있음

### 아키텍처 스타일의 비교
<table>
  <tr><td>스타일</td><td>장점</td><td>단점</td></tr>
  <tr><td>클라이언트 서버</td><td>- 클라이언트가 요청하는 서비스를 종합적으로 모델링하기 좋음</td><td>- 서비스요청이 서버에서 별도의 스레드로 처리
                                                                                                - 프로세스사이의 커뮤니케이션이 오버헤드 될 수 있음(클라언트들이 다른 표현 요구하기 떄문)</td></tr>
  <tr><td>계층형</td><td>- 하위층이 여러 상위층에 의하여 사용됨
- 각 층을 정확히 정의하면 각 층이 표준화 될 수 있음
- 다른 층에 영향을 주지 않고 수정을 층 안에 국한시킬 수 있음</td><td>- 광범위하게 적용하기 어려움 (이웃 층과의 커뮤니케이션이 제한적)
- 특정한 층이 상황에 따라 통과될 수도 있음</td></tr>
  <tr><td>이벤트 기반</td><td>- 이벤트 생산자, 소비자 연결을 쉽게 하고 추가할 수 있음
- 분산 응용에 효과적으로 적용 가능</td><td>- 상태에 따른 복잡하고 정교한 제어가 필요함
- 큰 규모에 적용하기 어려움</td></tr>
  <tr><td>mvc</td><td>- 동일 모델에 여러 가지 뷰를 런타임에 쉽게 연결하고 끊을 수 있음</td><td>- 복잡도가 증가하고 이로 인하여 사용자 액션을 위하여 불필요한 수정이 증가될 수 있음</td></tr>
  <tr><td>파이프 필터</td><td>- 병렬처리를 가능하게 함
- 쉽게 필터를 추가할 수 있고, 시스템이 확장될 수 있음</td><td>- 느린 필터에 의하여 시스템의 성능이 제한적이다
- 필터를 이동하면서 자료의 변환 오버헤드가 발생할 수 있음</td></tr>
  <tr><td>데이터 중심</td><td>- 새로운 응용을 쉽게 추가
- 데이터 공간의 확장이 용이함</td><td>- 모든 부분이 영향을 받아 중심 데이터의 구조를 변경하는 것이 쉽지 않다</td></tr>
  <tr><td>Peer-to-Peer</td><td>	- 중앙집중을 피할 수 있음
- 노드 하나의 고장으로 시스템이 멈추지 않음
- 자원과 컴퓨팅 파워의 확장성이 뛰어남</td><td>- 서비스의 품질을 보장하기 어려움
- 보안을 보장하기 어려움
- 성능이 노드의 수에 좌우됨</td></tr>
</table>


## 7-3 디자인 패턴
- 아키텍처 설계 수준보다 낮은 수준의 설계 문제에 재사용 가능한 솔루션 제공
  ![image](https://user-images.githubusercontent.com/64974683/205537880-bd3e08ea-5d58-42c9-9da2-c3f8b9462f52.png)

- 디자인 패턴을 이용하여 찾을 수 있는 두가지 솔루션
  - 옵서버 패턴에 따라 모델이 뷰의 상태 변경을 알리도록
  - 모델에 대한 변경이 컨트롤러에 의해 시작되다면 모델에 상태변경이 있을 때 컨트롤러가 뷰에 알리도록

### 7-3-1 디자인 패턴의 혜택(디자인 패턴을 사용하는 이유)
1. 쉽게 재사용 가능
2. 설계 작업이 쉬워짐(높은 품질의 솔루션이 이미 제공, 특정상황에 대하여 패턴을 특수화하는 방법을 알아야함)
3. 설계 관련 지식이 정리됨(디자인 패턴에 대한 학습은 개발자에게 제대로 된 걸계를 할 수 잇게 함)
4. 디자인을 논의하기 위한 의사소통이 쉬워짐(디자인 패턴은 설계에 대한 아이디어를 논의하기 위해 추상화 레벨에서 공통 어휘를 정의하고, 정확하게 설명하는 기틀 제공)
5. 객체 지향 설계 원리를 잘 따르게 됨






